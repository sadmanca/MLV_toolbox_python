
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>scipy.ndimage.morphology &#8212; MLV_toolbox_python 0.0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css" />
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for scipy.ndimage.morphology</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (C) 2003-2005 Peter J. Verveer</span>
<span class="c1">#</span>
<span class="c1"># Redistribution and use in source and binary forms, with or without</span>
<span class="c1"># modification, are permitted provided that the following conditions</span>
<span class="c1"># are met:</span>
<span class="c1">#</span>
<span class="c1"># 1. Redistributions of source code must retain the above copyright</span>
<span class="c1">#    notice, this list of conditions and the following disclaimer.</span>
<span class="c1">#</span>
<span class="c1"># 2. Redistributions in binary form must reproduce the above</span>
<span class="c1">#    copyright notice, this list of conditions and the following</span>
<span class="c1">#    disclaimer in the documentation and/or other materials provided</span>
<span class="c1">#    with the distribution.</span>
<span class="c1">#</span>
<span class="c1"># 3. The name of the author may not be used to endorse or promote</span>
<span class="c1">#    products derived from this software without specific prior</span>
<span class="c1">#    written permission.</span>
<span class="c1">#</span>
<span class="c1"># THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS&#39;&#39; AND ANY EXPRESS</span>
<span class="c1"># OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED</span>
<span class="c1"># WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
<span class="c1"># ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY</span>
<span class="c1"># DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span>
<span class="c1"># DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE</span>
<span class="c1"># GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
<span class="c1"># INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,</span>
<span class="c1"># WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING</span>
<span class="c1"># NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS</span>
<span class="c1"># SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>

<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">operator</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_ni_support</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_nd_image</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">filters</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;iterate_structure&#39;</span><span class="p">,</span> <span class="s1">&#39;generate_binary_structure&#39;</span><span class="p">,</span> <span class="s1">&#39;binary_erosion&#39;</span><span class="p">,</span>
           <span class="s1">&#39;binary_dilation&#39;</span><span class="p">,</span> <span class="s1">&#39;binary_opening&#39;</span><span class="p">,</span> <span class="s1">&#39;binary_closing&#39;</span><span class="p">,</span>
           <span class="s1">&#39;binary_hit_or_miss&#39;</span><span class="p">,</span> <span class="s1">&#39;binary_propagation&#39;</span><span class="p">,</span> <span class="s1">&#39;binary_fill_holes&#39;</span><span class="p">,</span>
           <span class="s1">&#39;grey_erosion&#39;</span><span class="p">,</span> <span class="s1">&#39;grey_dilation&#39;</span><span class="p">,</span> <span class="s1">&#39;grey_opening&#39;</span><span class="p">,</span> <span class="s1">&#39;grey_closing&#39;</span><span class="p">,</span>
           <span class="s1">&#39;morphological_gradient&#39;</span><span class="p">,</span> <span class="s1">&#39;morphological_laplace&#39;</span><span class="p">,</span> <span class="s1">&#39;white_tophat&#39;</span><span class="p">,</span>
           <span class="s1">&#39;black_tophat&#39;</span><span class="p">,</span> <span class="s1">&#39;distance_transform_bf&#39;</span><span class="p">,</span> <span class="s1">&#39;distance_transform_cdt&#39;</span><span class="p">,</span>
           <span class="s1">&#39;distance_transform_edt&#39;</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_center_is_true</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">origin</span><span class="p">):</span>
    <span class="n">structure</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span>
    <span class="n">coor</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">oo</span> <span class="o">+</span> <span class="n">ss</span> <span class="o">//</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">ss</span><span class="p">,</span> <span class="n">oo</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">structure</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                                 <span class="n">origin</span><span class="p">)])</span>
    <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">structure</span><span class="p">[</span><span class="n">coor</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">iterate_structure</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">iterations</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Iterate a structure by dilating it with itself.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    structure : array_like</span>
<span class="sd">       Structuring element (an array of bools, for example), to be dilated with</span>
<span class="sd">       itself.</span>
<span class="sd">    iterations : int</span>
<span class="sd">       number of dilations performed on the structure with itself</span>
<span class="sd">    origin : optional</span>
<span class="sd">        If origin is None, only the iterated structure is returned. If</span>
<span class="sd">        not, a tuple of the iterated structure and the modified origin is</span>
<span class="sd">        returned.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    iterate_structure : ndarray of bools</span>
<span class="sd">        A new structuring element obtained by dilating `structure`</span>
<span class="sd">        (`iterations` - 1) times with itself.</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    generate_binary_structure</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy import ndimage</span>
<span class="sd">    &gt;&gt;&gt; struct = ndimage.generate_binary_structure(2, 1)</span>
<span class="sd">    &gt;&gt;&gt; struct.astype(int)</span>
<span class="sd">    array([[0, 1, 0],</span>
<span class="sd">           [1, 1, 1],</span>
<span class="sd">           [0, 1, 0]])</span>
<span class="sd">    &gt;&gt;&gt; ndimage.iterate_structure(struct, 2).astype(int)</span>
<span class="sd">    array([[0, 0, 1, 0, 0],</span>
<span class="sd">           [0, 1, 1, 1, 0],</span>
<span class="sd">           [1, 1, 1, 1, 1],</span>
<span class="sd">           [0, 1, 1, 1, 0],</span>
<span class="sd">           [0, 0, 1, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; ndimage.iterate_structure(struct, 3).astype(int)</span>
<span class="sd">    array([[0, 0, 0, 1, 0, 0, 0],</span>
<span class="sd">           [0, 0, 1, 1, 1, 0, 0],</span>
<span class="sd">           [0, 1, 1, 1, 1, 1, 0],</span>
<span class="sd">           [1, 1, 1, 1, 1, 1, 1],</span>
<span class="sd">           [0, 1, 1, 1, 1, 1, 0],</span>
<span class="sd">           [0, 0, 1, 1, 1, 0, 0],</span>
<span class="sd">           [0, 0, 0, 1, 0, 0, 0]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">structure</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">iterations</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">structure</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">ni</span> <span class="o">=</span> <span class="n">iterations</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="n">ni</span> <span class="o">*</span> <span class="p">(</span><span class="n">ii</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">structure</span><span class="o">.</span><span class="n">shape</span><span class="p">]</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="p">[</span><span class="n">ni</span> <span class="o">*</span> <span class="p">(</span><span class="n">structure</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">))]</span>
    <span class="n">slc</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">pos</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">+</span> <span class="n">structure</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)))</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
    <span class="n">out</span><span class="p">[</span><span class="n">slc</span><span class="p">]</span> <span class="o">=</span> <span class="n">structure</span> <span class="o">!=</span> <span class="mi">0</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">binary_dilation</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="n">ni</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">origin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">out</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">origin</span> <span class="o">=</span> <span class="n">_ni_support</span><span class="o">.</span><span class="n">_normalize_sequence</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">structure</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
        <span class="n">origin</span> <span class="o">=</span> <span class="p">[</span><span class="n">iterations</span> <span class="o">*</span> <span class="n">o</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">origin</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">out</span><span class="p">,</span> <span class="n">origin</span>


<span class="k">def</span> <span class="nf">generate_binary_structure</span><span class="p">(</span><span class="n">rank</span><span class="p">,</span> <span class="n">connectivity</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a binary structure for binary morphological operations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rank : int</span>
<span class="sd">         Number of dimensions of the array to which the structuring element</span>
<span class="sd">         will be applied, as returned by `np.ndim`.</span>
<span class="sd">    connectivity : int</span>
<span class="sd">         `connectivity` determines which elements of the output array belong</span>
<span class="sd">         to the structure, i.e., are considered as neighbors of the central</span>
<span class="sd">         element. Elements up to a squared distance of `connectivity` from</span>
<span class="sd">         the center are considered neighbors. `connectivity` may range from 1</span>
<span class="sd">         (no diagonal elements are neighbors) to `rank` (all elements are</span>
<span class="sd">         neighbors).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    output : ndarray of bools</span>
<span class="sd">         Structuring element which may be used for binary morphological</span>
<span class="sd">         operations, with `rank` dimensions and all dimensions equal to 3.</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    iterate_structure, binary_dilation, binary_erosion</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    `generate_binary_structure` can only create structuring elements with</span>
<span class="sd">    dimensions equal to 3, i.e., minimal dimensions. For larger structuring</span>
<span class="sd">    elements, that are useful e.g., for eroding large objects, one may either</span>
<span class="sd">    use `iterate_structure`, or create directly custom arrays with</span>
<span class="sd">    numpy functions such as `numpy.ones`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy import ndimage</span>
<span class="sd">    &gt;&gt;&gt; struct = ndimage.generate_binary_structure(2, 1)</span>
<span class="sd">    &gt;&gt;&gt; struct</span>
<span class="sd">    array([[False,  True, False],</span>
<span class="sd">           [ True,  True,  True],</span>
<span class="sd">           [False,  True, False]], dtype=bool)</span>
<span class="sd">    &gt;&gt;&gt; a = np.zeros((5,5))</span>
<span class="sd">    &gt;&gt;&gt; a[2, 2] = 1</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[ 0.,  0.,  0.,  0.,  0.],</span>
<span class="sd">           [ 0.,  0.,  0.,  0.,  0.],</span>
<span class="sd">           [ 0.,  0.,  1.,  0.,  0.],</span>
<span class="sd">           [ 0.,  0.,  0.,  0.,  0.],</span>
<span class="sd">           [ 0.,  0.,  0.,  0.,  0.]])</span>
<span class="sd">    &gt;&gt;&gt; b = ndimage.binary_dilation(a, structure=struct).astype(a.dtype)</span>
<span class="sd">    &gt;&gt;&gt; b</span>
<span class="sd">    array([[ 0.,  0.,  0.,  0.,  0.],</span>
<span class="sd">           [ 0.,  0.,  1.,  0.,  0.],</span>
<span class="sd">           [ 0.,  1.,  1.,  1.,  0.],</span>
<span class="sd">           [ 0.,  0.,  1.,  0.,  0.],</span>
<span class="sd">           [ 0.,  0.,  0.,  0.,  0.]])</span>
<span class="sd">    &gt;&gt;&gt; ndimage.binary_dilation(b, structure=struct).astype(a.dtype)</span>
<span class="sd">    array([[ 0.,  0.,  1.,  0.,  0.],</span>
<span class="sd">           [ 0.,  1.,  1.,  1.,  0.],</span>
<span class="sd">           [ 1.,  1.,  1.,  1.,  1.],</span>
<span class="sd">           [ 0.,  1.,  1.,  1.,  0.],</span>
<span class="sd">           [ 0.,  0.,  1.,  0.,  0.]])</span>
<span class="sd">    &gt;&gt;&gt; struct = ndimage.generate_binary_structure(2, 2)</span>
<span class="sd">    &gt;&gt;&gt; struct</span>
<span class="sd">    array([[ True,  True,  True],</span>
<span class="sd">           [ True,  True,  True],</span>
<span class="sd">           [ True,  True,  True]], dtype=bool)</span>
<span class="sd">    &gt;&gt;&gt; struct = ndimage.generate_binary_structure(3, 1)</span>
<span class="sd">    &gt;&gt;&gt; struct # no diagonal elements</span>
<span class="sd">    array([[[False, False, False],</span>
<span class="sd">            [False,  True, False],</span>
<span class="sd">            [False, False, False]],</span>
<span class="sd">           [[False,  True, False],</span>
<span class="sd">            [ True,  True,  True],</span>
<span class="sd">            [False,  True, False]],</span>
<span class="sd">           [[False, False, False],</span>
<span class="sd">            [False,  True, False],</span>
<span class="sd">            [False, False, False]]], dtype=bool)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">connectivity</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">connectivity</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">rank</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">indices</span><span class="p">([</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">rank</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">output</span> <span class="o">&lt;=</span> <span class="n">connectivity</span>


<span class="k">def</span> <span class="nf">_binary_erosion</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">iterations</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span>
                    <span class="n">border_value</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">invert</span><span class="p">,</span> <span class="n">brute_force</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">iterations</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">iterations</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;iterations parameter should be an integer&#39;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

    <span class="nb">input</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="nb">input</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Complex type not supported&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">structure</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">structure</span> <span class="o">=</span> <span class="n">generate_binary_structure</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">structure</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">structure</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="nb">input</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;structure and input must have same dimensionality&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">structure</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">contiguous</span><span class="p">:</span>
        <span class="n">structure</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">structure</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;structure must not be empty&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="nb">input</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;mask and input must have equal sizes&#39;</span><span class="p">)</span>
    <span class="n">origin</span> <span class="o">=</span> <span class="n">_ni_support</span><span class="o">.</span><span class="n">_normalize_sequence</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="nb">input</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
    <span class="n">cit</span> <span class="o">=</span> <span class="n">_center_is_true</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">output</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Complex output type not supported&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">output</span> <span class="o">=</span> <span class="nb">bool</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">_ni_support</span><span class="o">.</span><span class="n">_get_output</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="nb">input</span><span class="p">)</span>
    <span class="n">temp_needed</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">may_share_memory</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">temp_needed</span><span class="p">:</span>
        <span class="c1"># input and output arrays cannot share memory</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">output</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">_ni_support</span><span class="o">.</span><span class="n">_get_output</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">input</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">iterations</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">_nd_image</span><span class="o">.</span><span class="n">binary_erosion</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span>
                                 <span class="n">border_value</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">invert</span><span class="p">,</span> <span class="n">cit</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span>
    <span class="k">elif</span> <span class="n">cit</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">brute_force</span><span class="p">:</span>
        <span class="n">changed</span><span class="p">,</span> <span class="n">coordinate_list</span> <span class="o">=</span> <span class="n">_nd_image</span><span class="o">.</span><span class="n">binary_erosion</span><span class="p">(</span>
            <span class="nb">input</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span>
            <span class="n">border_value</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">invert</span><span class="p">,</span> <span class="n">cit</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">structure</span> <span class="o">=</span> <span class="n">structure</span><span class="p">[</span><span class="nb">tuple</span><span class="p">([</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="o">*</span>
                                    <span class="n">structure</span><span class="o">.</span><span class="n">ndim</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">origin</span><span class="p">)):</span>
            <span class="n">origin</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">origin</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">structure</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">origin</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">structure</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">contiguous</span><span class="p">:</span>
            <span class="n">structure</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">_nd_image</span><span class="o">.</span><span class="n">binary_erosion2</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">iterations</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                                  <span class="n">origin</span><span class="p">,</span> <span class="n">invert</span><span class="p">,</span> <span class="n">coordinate_list</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tmp_in</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">tmp_out</span> <span class="o">=</span> <span class="n">output</span>
        <span class="k">if</span> <span class="n">iterations</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">iterations</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">tmp_in</span><span class="p">,</span> <span class="n">tmp_out</span> <span class="o">=</span> <span class="n">tmp_out</span><span class="p">,</span> <span class="n">tmp_in</span>
        <span class="n">changed</span> <span class="o">=</span> <span class="n">_nd_image</span><span class="o">.</span><span class="n">binary_erosion</span><span class="p">(</span>
            <span class="nb">input</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">tmp_out</span><span class="p">,</span>
            <span class="n">border_value</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">invert</span><span class="p">,</span> <span class="n">cit</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">ii</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">ii</span> <span class="o">&lt;</span> <span class="n">iterations</span> <span class="ow">or</span> <span class="p">(</span><span class="n">iterations</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">changed</span><span class="p">):</span>
            <span class="n">tmp_in</span><span class="p">,</span> <span class="n">tmp_out</span> <span class="o">=</span> <span class="n">tmp_out</span><span class="p">,</span> <span class="n">tmp_in</span>
            <span class="n">changed</span> <span class="o">=</span> <span class="n">_nd_image</span><span class="o">.</span><span class="n">binary_erosion</span><span class="p">(</span>
                <span class="n">tmp_in</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">tmp_out</span><span class="p">,</span>
                <span class="n">border_value</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">invert</span><span class="p">,</span> <span class="n">cit</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">ii</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">temp_needed</span><span class="p">:</span>
        <span class="n">temp</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">output</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">temp</span>
    <span class="k">return</span> <span class="n">output</span>


<span class="k">def</span> <span class="nf">binary_erosion</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">border_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">brute_force</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Multidimensional binary erosion with a given structuring element.</span>

<span class="sd">    Binary erosion is a mathematical morphology operation used for image</span>
<span class="sd">    processing.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input : array_like</span>
<span class="sd">        Binary image to be eroded. Non-zero (True) elements form</span>
<span class="sd">        the subset to be eroded.</span>
<span class="sd">    structure : array_like, optional</span>
<span class="sd">        Structuring element used for the erosion. Non-zero elements are</span>
<span class="sd">        considered True. If no structuring element is provided, an element</span>
<span class="sd">        is generated with a square connectivity equal to one.</span>
<span class="sd">    iterations : int, optional</span>
<span class="sd">        The erosion is repeated `iterations` times (one, by default).</span>
<span class="sd">        If iterations is less than 1, the erosion is repeated until the</span>
<span class="sd">        result does not change anymore.</span>
<span class="sd">    mask : array_like, optional</span>
<span class="sd">        If a mask is given, only those elements with a True value at</span>
<span class="sd">        the corresponding mask element are modified at each iteration.</span>
<span class="sd">    output : ndarray, optional</span>
<span class="sd">        Array of the same shape as input, into which the output is placed.</span>
<span class="sd">        By default, a new array is created.</span>
<span class="sd">    border_value : int (cast to 0 or 1), optional</span>
<span class="sd">        Value at the border in the output array.</span>
<span class="sd">    origin : int or tuple of ints, optional</span>
<span class="sd">        Placement of the filter, by default 0.</span>
<span class="sd">    brute_force : boolean, optional</span>
<span class="sd">        Memory condition: if False, only the pixels whose value was changed in</span>
<span class="sd">        the last iteration are tracked as candidates to be updated (eroded) in</span>
<span class="sd">        the current iteration; if True all pixels are considered as candidates</span>
<span class="sd">        for erosion, regardless of what happened in the previous iteration.</span>
<span class="sd">        False by default.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    binary_erosion : ndarray of bools</span>
<span class="sd">        Erosion of the input by the structuring element.</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    grey_erosion, binary_dilation, binary_closing, binary_opening,</span>
<span class="sd">    generate_binary_structure</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Erosion [1]_ is a mathematical morphology operation [2]_ that uses a</span>
<span class="sd">    structuring element for shrinking the shapes in an image. The binary</span>
<span class="sd">    erosion of an image by a structuring element is the locus of the points</span>
<span class="sd">    where a superimposition of the structuring element centered on the point</span>
<span class="sd">    is entirely contained in the set of non-zero elements of the image.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] https://en.wikipedia.org/wiki/Erosion_%28morphology%29</span>
<span class="sd">    .. [2] https://en.wikipedia.org/wiki/Mathematical_morphology</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy import ndimage</span>
<span class="sd">    &gt;&gt;&gt; a = np.zeros((7,7), dtype=int)</span>
<span class="sd">    &gt;&gt;&gt; a[1:6, 2:5] = 1</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 1, 1, 1, 0, 0],</span>
<span class="sd">           [0, 0, 1, 1, 1, 0, 0],</span>
<span class="sd">           [0, 0, 1, 1, 1, 0, 0],</span>
<span class="sd">           [0, 0, 1, 1, 1, 0, 0],</span>
<span class="sd">           [0, 0, 1, 1, 1, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; ndimage.binary_erosion(a).astype(a.dtype)</span>
<span class="sd">    array([[0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 1, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 1, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 1, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; #Erosion removes objects smaller than the structure</span>
<span class="sd">    &gt;&gt;&gt; ndimage.binary_erosion(a, structure=np.ones((5,5))).astype(a.dtype)</span>
<span class="sd">    array([[0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_binary_erosion</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">iterations</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span>
                           <span class="n">output</span><span class="p">,</span> <span class="n">border_value</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">brute_force</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">binary_dilation</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">output</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">border_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">brute_force</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Multidimensional binary dilation with the given structuring element.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input : array_like</span>
<span class="sd">        Binary array_like to be dilated. Non-zero (True) elements form</span>
<span class="sd">        the subset to be dilated.</span>
<span class="sd">    structure : array_like, optional</span>
<span class="sd">        Structuring element used for the dilation. Non-zero elements are</span>
<span class="sd">        considered True. If no structuring element is provided an element</span>
<span class="sd">        is generated with a square connectivity equal to one.</span>
<span class="sd">    iterations : int, optional</span>
<span class="sd">        The dilation is repeated `iterations` times (one, by default).</span>
<span class="sd">        If iterations is less than 1, the dilation is repeated until the</span>
<span class="sd">        result does not change anymore. Only an integer of iterations is</span>
<span class="sd">        accepted.</span>
<span class="sd">    mask : array_like, optional</span>
<span class="sd">        If a mask is given, only those elements with a True value at</span>
<span class="sd">        the corresponding mask element are modified at each iteration.</span>
<span class="sd">    output : ndarray, optional</span>
<span class="sd">        Array of the same shape as input, into which the output is placed.</span>
<span class="sd">        By default, a new array is created.</span>
<span class="sd">    border_value : int (cast to 0 or 1), optional</span>
<span class="sd">        Value at the border in the output array.</span>
<span class="sd">    origin : int or tuple of ints, optional</span>
<span class="sd">        Placement of the filter, by default 0.</span>
<span class="sd">    brute_force : boolean, optional</span>
<span class="sd">        Memory condition: if False, only the pixels whose value was changed in</span>
<span class="sd">        the last iteration are tracked as candidates to be updated (dilated)</span>
<span class="sd">        in the current iteration; if True all pixels are considered as</span>
<span class="sd">        candidates for dilation, regardless of what happened in the previous</span>
<span class="sd">        iteration. False by default.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    binary_dilation : ndarray of bools</span>
<span class="sd">        Dilation of the input by the structuring element.</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    grey_dilation, binary_erosion, binary_closing, binary_opening,</span>
<span class="sd">    generate_binary_structure</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Dilation [1]_ is a mathematical morphology operation [2]_ that uses a</span>
<span class="sd">    structuring element for expanding the shapes in an image. The binary</span>
<span class="sd">    dilation of an image by a structuring element is the locus of the points</span>
<span class="sd">    covered by the structuring element, when its center lies within the</span>
<span class="sd">    non-zero points of the image.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] https://en.wikipedia.org/wiki/Dilation_%28morphology%29</span>
<span class="sd">    .. [2] https://en.wikipedia.org/wiki/Mathematical_morphology</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy import ndimage</span>
<span class="sd">    &gt;&gt;&gt; a = np.zeros((5, 5))</span>
<span class="sd">    &gt;&gt;&gt; a[2, 2] = 1</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[ 0.,  0.,  0.,  0.,  0.],</span>
<span class="sd">           [ 0.,  0.,  0.,  0.,  0.],</span>
<span class="sd">           [ 0.,  0.,  1.,  0.,  0.],</span>
<span class="sd">           [ 0.,  0.,  0.,  0.,  0.],</span>
<span class="sd">           [ 0.,  0.,  0.,  0.,  0.]])</span>
<span class="sd">    &gt;&gt;&gt; ndimage.binary_dilation(a)</span>
<span class="sd">    array([[False, False, False, False, False],</span>
<span class="sd">           [False, False,  True, False, False],</span>
<span class="sd">           [False,  True,  True,  True, False],</span>
<span class="sd">           [False, False,  True, False, False],</span>
<span class="sd">           [False, False, False, False, False]], dtype=bool)</span>
<span class="sd">    &gt;&gt;&gt; ndimage.binary_dilation(a).astype(a.dtype)</span>
<span class="sd">    array([[ 0.,  0.,  0.,  0.,  0.],</span>
<span class="sd">           [ 0.,  0.,  1.,  0.,  0.],</span>
<span class="sd">           [ 0.,  1.,  1.,  1.,  0.],</span>
<span class="sd">           [ 0.,  0.,  1.,  0.,  0.],</span>
<span class="sd">           [ 0.,  0.,  0.,  0.,  0.]])</span>
<span class="sd">    &gt;&gt;&gt; # 3x3 structuring element with connectivity 1, used by default</span>
<span class="sd">    &gt;&gt;&gt; struct1 = ndimage.generate_binary_structure(2, 1)</span>
<span class="sd">    &gt;&gt;&gt; struct1</span>
<span class="sd">    array([[False,  True, False],</span>
<span class="sd">           [ True,  True,  True],</span>
<span class="sd">           [False,  True, False]], dtype=bool)</span>
<span class="sd">    &gt;&gt;&gt; # 3x3 structuring element with connectivity 2</span>
<span class="sd">    &gt;&gt;&gt; struct2 = ndimage.generate_binary_structure(2, 2)</span>
<span class="sd">    &gt;&gt;&gt; struct2</span>
<span class="sd">    array([[ True,  True,  True],</span>
<span class="sd">           [ True,  True,  True],</span>
<span class="sd">           [ True,  True,  True]], dtype=bool)</span>
<span class="sd">    &gt;&gt;&gt; ndimage.binary_dilation(a, structure=struct1).astype(a.dtype)</span>
<span class="sd">    array([[ 0.,  0.,  0.,  0.,  0.],</span>
<span class="sd">           [ 0.,  0.,  1.,  0.,  0.],</span>
<span class="sd">           [ 0.,  1.,  1.,  1.,  0.],</span>
<span class="sd">           [ 0.,  0.,  1.,  0.,  0.],</span>
<span class="sd">           [ 0.,  0.,  0.,  0.,  0.]])</span>
<span class="sd">    &gt;&gt;&gt; ndimage.binary_dilation(a, structure=struct2).astype(a.dtype)</span>
<span class="sd">    array([[ 0.,  0.,  0.,  0.,  0.],</span>
<span class="sd">           [ 0.,  1.,  1.,  1.,  0.],</span>
<span class="sd">           [ 0.,  1.,  1.,  1.,  0.],</span>
<span class="sd">           [ 0.,  1.,  1.,  1.,  0.],</span>
<span class="sd">           [ 0.,  0.,  0.,  0.,  0.]])</span>
<span class="sd">    &gt;&gt;&gt; ndimage.binary_dilation(a, structure=struct1,\\</span>
<span class="sd">    ... iterations=2).astype(a.dtype)</span>
<span class="sd">    array([[ 0.,  0.,  1.,  0.,  0.],</span>
<span class="sd">           [ 0.,  1.,  1.,  1.,  0.],</span>
<span class="sd">           [ 1.,  1.,  1.,  1.,  1.],</span>
<span class="sd">           [ 0.,  1.,  1.,  1.,  0.],</span>
<span class="sd">           [ 0.,  0.,  1.,  0.,  0.]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">input</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">structure</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">structure</span> <span class="o">=</span> <span class="n">generate_binary_structure</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">origin</span> <span class="o">=</span> <span class="n">_ni_support</span><span class="o">.</span><span class="n">_normalize_sequence</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="nb">input</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
    <span class="n">structure</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span>
    <span class="n">structure</span> <span class="o">=</span> <span class="n">structure</span><span class="p">[</span><span class="nb">tuple</span><span class="p">([</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="o">*</span>
                                <span class="n">structure</span><span class="o">.</span><span class="n">ndim</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">origin</span><span class="p">)):</span>
        <span class="n">origin</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">origin</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">structure</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">origin</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">_binary_erosion</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">iterations</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span>
                           <span class="n">output</span><span class="p">,</span> <span class="n">border_value</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">brute_force</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">binary_opening</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">origin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">border_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">brute_force</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Multidimensional binary opening with the given structuring element.</span>

<span class="sd">    The *opening* of an input image by a structuring element is the</span>
<span class="sd">    *dilation* of the *erosion* of the image by the structuring element.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input : array_like</span>
<span class="sd">        Binary array_like to be opened. Non-zero (True) elements form</span>
<span class="sd">        the subset to be opened.</span>
<span class="sd">    structure : array_like, optional</span>
<span class="sd">        Structuring element used for the opening. Non-zero elements are</span>
<span class="sd">        considered True. If no structuring element is provided an element</span>
<span class="sd">        is generated with a square connectivity equal to one (i.e., only</span>
<span class="sd">        nearest neighbors are connected to the center, diagonally-connected</span>
<span class="sd">        elements are not considered neighbors).</span>
<span class="sd">    iterations : int, optional</span>
<span class="sd">        The erosion step of the opening, then the dilation step are each</span>
<span class="sd">        repeated `iterations` times (one, by default). If `iterations` is</span>
<span class="sd">        less than 1, each operation is repeated until the result does</span>
<span class="sd">        not change anymore. Only an integer of iterations is accepted.</span>
<span class="sd">    output : ndarray, optional</span>
<span class="sd">        Array of the same shape as input, into which the output is placed.</span>
<span class="sd">        By default, a new array is created.</span>
<span class="sd">    origin : int or tuple of ints, optional</span>
<span class="sd">        Placement of the filter, by default 0.</span>
<span class="sd">    mask : array_like, optional</span>
<span class="sd">        If a mask is given, only those elements with a True value at</span>
<span class="sd">        the corresponding mask element are modified at each iteration.</span>

<span class="sd">        .. versionadded:: 1.1.0</span>
<span class="sd">    border_value : int (cast to 0 or 1), optional</span>
<span class="sd">        Value at the border in the output array.</span>

<span class="sd">        .. versionadded:: 1.1.0</span>
<span class="sd">    brute_force : boolean, optional</span>
<span class="sd">        Memory condition: if False, only the pixels whose value was changed in</span>
<span class="sd">        the last iteration are tracked as candidates to be updated in the</span>
<span class="sd">        current iteration; if true all pixels are considered as candidates for</span>
<span class="sd">        update, regardless of what happened in the previous iteration.</span>
<span class="sd">        False by default.</span>

<span class="sd">        .. versionadded:: 1.1.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    binary_opening : ndarray of bools</span>
<span class="sd">        Opening of the input by the structuring element.</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    grey_opening, binary_closing, binary_erosion, binary_dilation,</span>
<span class="sd">    generate_binary_structure</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    *Opening* [1]_ is a mathematical morphology operation [2]_ that</span>
<span class="sd">    consists in the succession of an erosion and a dilation of the</span>
<span class="sd">    input with the same structuring element. Opening, therefore, removes</span>
<span class="sd">    objects smaller than the structuring element.</span>

<span class="sd">    Together with *closing* (`binary_closing`), opening can be used for</span>
<span class="sd">    noise removal.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] https://en.wikipedia.org/wiki/Opening_%28morphology%29</span>
<span class="sd">    .. [2] https://en.wikipedia.org/wiki/Mathematical_morphology</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy import ndimage</span>
<span class="sd">    &gt;&gt;&gt; a = np.zeros((5,5), dtype=int)</span>
<span class="sd">    &gt;&gt;&gt; a[1:4, 1:4] = 1; a[4, 4] = 1</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 1, 1, 1, 0],</span>
<span class="sd">           [0, 1, 1, 1, 0],</span>
<span class="sd">           [0, 1, 1, 1, 0],</span>
<span class="sd">           [0, 0, 0, 0, 1]])</span>
<span class="sd">    &gt;&gt;&gt; # Opening removes small objects</span>
<span class="sd">    &gt;&gt;&gt; ndimage.binary_opening(a, structure=np.ones((3,3))).astype(int)</span>
<span class="sd">    array([[0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 1, 1, 1, 0],</span>
<span class="sd">           [0, 1, 1, 1, 0],</span>
<span class="sd">           [0, 1, 1, 1, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; # Opening can also smooth corners</span>
<span class="sd">    &gt;&gt;&gt; ndimage.binary_opening(a).astype(int)</span>
<span class="sd">    array([[0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 1, 0, 0],</span>
<span class="sd">           [0, 1, 1, 1, 0],</span>
<span class="sd">           [0, 0, 1, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; # Opening is the dilation of the erosion of the input</span>
<span class="sd">    &gt;&gt;&gt; ndimage.binary_erosion(a).astype(int)</span>
<span class="sd">    array([[0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 1, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; ndimage.binary_dilation(ndimage.binary_erosion(a)).astype(int)</span>
<span class="sd">    array([[0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 1, 0, 0],</span>
<span class="sd">           [0, 1, 1, 1, 0],</span>
<span class="sd">           [0, 0, 1, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">input</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">structure</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">structure</span> <span class="o">=</span> <span class="n">generate_binary_structure</span><span class="p">(</span><span class="n">rank</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">tmp</span> <span class="o">=</span> <span class="n">binary_erosion</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">iterations</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="n">border_value</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">brute_force</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">binary_dilation</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">iterations</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span>
                           <span class="n">border_value</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">brute_force</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">binary_closing</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">origin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">border_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">brute_force</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Multidimensional binary closing with the given structuring element.</span>

<span class="sd">    The *closing* of an input image by a structuring element is the</span>
<span class="sd">    *erosion* of the *dilation* of the image by the structuring element.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input : array_like</span>
<span class="sd">        Binary array_like to be closed. Non-zero (True) elements form</span>
<span class="sd">        the subset to be closed.</span>
<span class="sd">    structure : array_like, optional</span>
<span class="sd">        Structuring element used for the closing. Non-zero elements are</span>
<span class="sd">        considered True. If no structuring element is provided an element</span>
<span class="sd">        is generated with a square connectivity equal to one (i.e., only</span>
<span class="sd">        nearest neighbors are connected to the center, diagonally-connected</span>
<span class="sd">        elements are not considered neighbors).</span>
<span class="sd">    iterations : int, optional</span>
<span class="sd">        The dilation step of the closing, then the erosion step are each</span>
<span class="sd">        repeated `iterations` times (one, by default). If iterations is</span>
<span class="sd">        less than 1, each operations is repeated until the result does</span>
<span class="sd">        not change anymore. Only an integer of iterations is accepted.</span>
<span class="sd">    output : ndarray, optional</span>
<span class="sd">        Array of the same shape as input, into which the output is placed.</span>
<span class="sd">        By default, a new array is created.</span>
<span class="sd">    origin : int or tuple of ints, optional</span>
<span class="sd">        Placement of the filter, by default 0.</span>
<span class="sd">    mask : array_like, optional</span>
<span class="sd">        If a mask is given, only those elements with a True value at</span>
<span class="sd">        the corresponding mask element are modified at each iteration.</span>

<span class="sd">        .. versionadded:: 1.1.0</span>
<span class="sd">    border_value : int (cast to 0 or 1), optional</span>
<span class="sd">        Value at the border in the output array.</span>

<span class="sd">        .. versionadded:: 1.1.0</span>
<span class="sd">    brute_force : boolean, optional</span>
<span class="sd">        Memory condition: if False, only the pixels whose value was changed in</span>
<span class="sd">        the last iteration are tracked as candidates to be updated in the</span>
<span class="sd">        current iteration; if true al pixels are considered as candidates for</span>
<span class="sd">        update, regardless of what happened in the previous iteration.</span>
<span class="sd">        False by default.</span>

<span class="sd">        .. versionadded:: 1.1.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    binary_closing : ndarray of bools</span>
<span class="sd">        Closing of the input by the structuring element.</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    grey_closing, binary_opening, binary_dilation, binary_erosion,</span>
<span class="sd">    generate_binary_structure</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    *Closing* [1]_ is a mathematical morphology operation [2]_ that</span>
<span class="sd">    consists in the succession of a dilation and an erosion of the</span>
<span class="sd">    input with the same structuring element. Closing therefore fills</span>
<span class="sd">    holes smaller than the structuring element.</span>

<span class="sd">    Together with *opening* (`binary_opening`), closing can be used for</span>
<span class="sd">    noise removal.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] https://en.wikipedia.org/wiki/Closing_%28morphology%29</span>
<span class="sd">    .. [2] https://en.wikipedia.org/wiki/Mathematical_morphology</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy import ndimage</span>
<span class="sd">    &gt;&gt;&gt; a = np.zeros((5,5), dtype=int)</span>
<span class="sd">    &gt;&gt;&gt; a[1:-1, 1:-1] = 1; a[2,2] = 0</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 1, 1, 1, 0],</span>
<span class="sd">           [0, 1, 0, 1, 0],</span>
<span class="sd">           [0, 1, 1, 1, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; # Closing removes small holes</span>
<span class="sd">    &gt;&gt;&gt; ndimage.binary_closing(a).astype(int)</span>
<span class="sd">    array([[0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 1, 1, 1, 0],</span>
<span class="sd">           [0, 1, 1, 1, 0],</span>
<span class="sd">           [0, 1, 1, 1, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; # Closing is the erosion of the dilation of the input</span>
<span class="sd">    &gt;&gt;&gt; ndimage.binary_dilation(a).astype(int)</span>
<span class="sd">    array([[0, 1, 1, 1, 0],</span>
<span class="sd">           [1, 1, 1, 1, 1],</span>
<span class="sd">           [1, 1, 1, 1, 1],</span>
<span class="sd">           [1, 1, 1, 1, 1],</span>
<span class="sd">           [0, 1, 1, 1, 0]])</span>
<span class="sd">    &gt;&gt;&gt; ndimage.binary_erosion(ndimage.binary_dilation(a)).astype(int)</span>
<span class="sd">    array([[0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 1, 1, 1, 0],</span>
<span class="sd">           [0, 1, 1, 1, 0],</span>
<span class="sd">           [0, 1, 1, 1, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0]])</span>


<span class="sd">    &gt;&gt;&gt; a = np.zeros((7,7), dtype=int)</span>
<span class="sd">    &gt;&gt;&gt; a[1:6, 2:5] = 1; a[1:3,3] = 0</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 1, 0, 1, 0, 0],</span>
<span class="sd">           [0, 0, 1, 0, 1, 0, 0],</span>
<span class="sd">           [0, 0, 1, 1, 1, 0, 0],</span>
<span class="sd">           [0, 0, 1, 1, 1, 0, 0],</span>
<span class="sd">           [0, 0, 1, 1, 1, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; # In addition to removing holes, closing can also</span>
<span class="sd">    &gt;&gt;&gt; # coarsen boundaries with fine hollows.</span>
<span class="sd">    &gt;&gt;&gt; ndimage.binary_closing(a).astype(int)</span>
<span class="sd">    array([[0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 1, 0, 1, 0, 0],</span>
<span class="sd">           [0, 0, 1, 1, 1, 0, 0],</span>
<span class="sd">           [0, 0, 1, 1, 1, 0, 0],</span>
<span class="sd">           [0, 0, 1, 1, 1, 0, 0],</span>
<span class="sd">           [0, 0, 1, 1, 1, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; ndimage.binary_closing(a, structure=np.ones((2,2))).astype(int)</span>
<span class="sd">    array([[0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 1, 1, 1, 0, 0],</span>
<span class="sd">           [0, 0, 1, 1, 1, 0, 0],</span>
<span class="sd">           [0, 0, 1, 1, 1, 0, 0],</span>
<span class="sd">           [0, 0, 1, 1, 1, 0, 0],</span>
<span class="sd">           [0, 0, 1, 1, 1, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">input</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">structure</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">structure</span> <span class="o">=</span> <span class="n">generate_binary_structure</span><span class="p">(</span><span class="n">rank</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">tmp</span> <span class="o">=</span> <span class="n">binary_dilation</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">iterations</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                          <span class="n">border_value</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">brute_force</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">binary_erosion</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">iterations</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span>
                          <span class="n">border_value</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">brute_force</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">binary_hit_or_miss</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">structure1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">structure2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">output</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">origin1</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">origin2</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Multidimensional binary hit-or-miss transform.</span>

<span class="sd">    The hit-or-miss transform finds the locations of a given pattern</span>
<span class="sd">    inside the input image.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input : array_like (cast to booleans)</span>
<span class="sd">        Binary image where a pattern is to be detected.</span>
<span class="sd">    structure1 : array_like (cast to booleans), optional</span>
<span class="sd">        Part of the structuring element to be fitted to the foreground</span>
<span class="sd">        (non-zero elements) of `input`. If no value is provided, a</span>
<span class="sd">        structure of square connectivity 1 is chosen.</span>
<span class="sd">    structure2 : array_like (cast to booleans), optional</span>
<span class="sd">        Second part of the structuring element that has to miss completely</span>
<span class="sd">        the foreground. If no value is provided, the complementary of</span>
<span class="sd">        `structure1` is taken.</span>
<span class="sd">    output : ndarray, optional</span>
<span class="sd">        Array of the same shape as input, into which the output is placed.</span>
<span class="sd">        By default, a new array is created.</span>
<span class="sd">    origin1 : int or tuple of ints, optional</span>
<span class="sd">        Placement of the first part of the structuring element `structure1`,</span>
<span class="sd">        by default 0 for a centered structure.</span>
<span class="sd">    origin2 : int or tuple of ints, optional</span>
<span class="sd">        Placement of the second part of the structuring element `structure2`,</span>
<span class="sd">        by default 0 for a centered structure. If a value is provided for</span>
<span class="sd">        `origin1` and not for `origin2`, then `origin2` is set to `origin1`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    binary_hit_or_miss : ndarray</span>
<span class="sd">        Hit-or-miss transform of `input` with the given structuring</span>
<span class="sd">        element (`structure1`, `structure2`).</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    binary_erosion</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] https://en.wikipedia.org/wiki/Hit-or-miss_transform</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy import ndimage</span>
<span class="sd">    &gt;&gt;&gt; a = np.zeros((7,7), dtype=int)</span>
<span class="sd">    &gt;&gt;&gt; a[1, 1] = 1; a[2:4, 2:4] = 1; a[4:6, 4:6] = 1</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 1, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 1, 1, 0, 0, 0],</span>
<span class="sd">           [0, 0, 1, 1, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 1, 1, 0],</span>
<span class="sd">           [0, 0, 0, 0, 1, 1, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; structure1 = np.array([[1, 0, 0], [0, 1, 1], [0, 1, 1]])</span>
<span class="sd">    &gt;&gt;&gt; structure1</span>
<span class="sd">    array([[1, 0, 0],</span>
<span class="sd">           [0, 1, 1],</span>
<span class="sd">           [0, 1, 1]])</span>
<span class="sd">    &gt;&gt;&gt; # Find the matches of structure1 in the array a</span>
<span class="sd">    &gt;&gt;&gt; ndimage.binary_hit_or_miss(a, structure1=structure1).astype(int)</span>
<span class="sd">    array([[0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 1, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 1, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; # Change the origin of the filter</span>
<span class="sd">    &gt;&gt;&gt; # origin1=1 is equivalent to origin1=(1,1) here</span>
<span class="sd">    &gt;&gt;&gt; ndimage.binary_hit_or_miss(a, structure1=structure1,\\</span>
<span class="sd">    ... origin1=1).astype(int)</span>
<span class="sd">    array([[0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 1, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 1, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">input</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">structure1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">structure1</span> <span class="o">=</span> <span class="n">generate_binary_structure</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">structure2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">structure2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">structure1</span><span class="p">)</span>
    <span class="n">origin1</span> <span class="o">=</span> <span class="n">_ni_support</span><span class="o">.</span><span class="n">_normalize_sequence</span><span class="p">(</span><span class="n">origin1</span><span class="p">,</span> <span class="nb">input</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">origin2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">origin2</span> <span class="o">=</span> <span class="n">origin1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">origin2</span> <span class="o">=</span> <span class="n">_ni_support</span><span class="o">.</span><span class="n">_normalize_sequence</span><span class="p">(</span><span class="n">origin2</span><span class="p">,</span> <span class="nb">input</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>

    <span class="n">tmp1</span> <span class="o">=</span> <span class="n">_binary_erosion</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">structure1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">origin1</span><span class="p">,</span>
                           <span class="mi">0</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">inplace</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">_binary_erosion</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">structure2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                             <span class="n">origin2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">tmp1</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">tmp1</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">binary_propagation</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">output</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">border_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Multidimensional binary propagation with the given structuring element.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input : array_like</span>
<span class="sd">        Binary image to be propagated inside `mask`.</span>
<span class="sd">    structure : array_like, optional</span>
<span class="sd">        Structuring element used in the successive dilations. The output</span>
<span class="sd">        may depend on the structuring element, especially if `mask` has</span>
<span class="sd">        several connex components. If no structuring element is</span>
<span class="sd">        provided, an element is generated with a squared connectivity equal</span>
<span class="sd">        to one.</span>
<span class="sd">    mask : array_like, optional</span>
<span class="sd">        Binary mask defining the region into which `input` is allowed to</span>
<span class="sd">        propagate.</span>
<span class="sd">    output : ndarray, optional</span>
<span class="sd">        Array of the same shape as input, into which the output is placed.</span>
<span class="sd">        By default, a new array is created.</span>
<span class="sd">    border_value : int (cast to 0 or 1), optional</span>
<span class="sd">        Value at the border in the output array.</span>
<span class="sd">    origin : int or tuple of ints, optional</span>
<span class="sd">        Placement of the filter, by default 0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    binary_propagation : ndarray</span>
<span class="sd">        Binary propagation of `input` inside `mask`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function is functionally equivalent to calling binary_dilation</span>
<span class="sd">    with the number of iterations less than one: iterative dilation until</span>
<span class="sd">    the result does not change anymore.</span>

<span class="sd">    The succession of an erosion and propagation inside the original image</span>
<span class="sd">    can be used instead of an *opening* for deleting small objects while</span>
<span class="sd">    keeping the contours of larger objects untouched.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] http://cmm.ensmp.fr/~serra/cours/pdf/en/ch6en.pdf, slide 15.</span>
<span class="sd">    .. [2] I.T. Young, J.J. Gerbrands, and L.J. van Vliet, &quot;Fundamentals of</span>
<span class="sd">        image processing&quot;, 1998</span>
<span class="sd">        ftp://qiftp.tudelft.nl/DIPimage/docs/FIP2.3.pdf</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy import ndimage</span>
<span class="sd">    &gt;&gt;&gt; input = np.zeros((8, 8), dtype=int)</span>
<span class="sd">    &gt;&gt;&gt; input[2, 2] = 1</span>
<span class="sd">    &gt;&gt;&gt; mask = np.zeros((8, 8), dtype=int)</span>
<span class="sd">    &gt;&gt;&gt; mask[1:4, 1:4] = mask[4, 4]  = mask[6:8, 6:8] = 1</span>
<span class="sd">    &gt;&gt;&gt; input</span>
<span class="sd">    array([[0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 1, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; mask</span>
<span class="sd">    array([[0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 1, 1, 1, 0, 0, 0, 0],</span>
<span class="sd">           [0, 1, 1, 1, 0, 0, 0, 0],</span>
<span class="sd">           [0, 1, 1, 1, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 1, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 1, 1],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 1, 1]])</span>
<span class="sd">    &gt;&gt;&gt; ndimage.binary_propagation(input, mask=mask).astype(int)</span>
<span class="sd">    array([[0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 1, 1, 1, 0, 0, 0, 0],</span>
<span class="sd">           [0, 1, 1, 1, 0, 0, 0, 0],</span>
<span class="sd">           [0, 1, 1, 1, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; ndimage.binary_propagation(input, mask=mask,\\</span>
<span class="sd">    ... structure=np.ones((3,3))).astype(int)</span>
<span class="sd">    array([[0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 1, 1, 1, 0, 0, 0, 0],</span>
<span class="sd">           [0, 1, 1, 1, 0, 0, 0, 0],</span>
<span class="sd">           [0, 1, 1, 1, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 1, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0, 0]])</span>

<span class="sd">    &gt;&gt;&gt; # Comparison between opening and erosion+propagation</span>
<span class="sd">    &gt;&gt;&gt; a = np.zeros((6,6), dtype=int)</span>
<span class="sd">    &gt;&gt;&gt; a[2:5, 2:5] = 1; a[0, 0] = 1; a[5, 5] = 1</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[1, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 1, 1, 1, 0],</span>
<span class="sd">           [0, 0, 1, 1, 1, 0],</span>
<span class="sd">           [0, 0, 1, 1, 1, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 1]])</span>
<span class="sd">    &gt;&gt;&gt; ndimage.binary_opening(a).astype(int)</span>
<span class="sd">    array([[0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 1, 0, 0],</span>
<span class="sd">           [0, 0, 1, 1, 1, 0],</span>
<span class="sd">           [0, 0, 0, 1, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; b = ndimage.binary_erosion(a)</span>
<span class="sd">    &gt;&gt;&gt; b.astype(int)</span>
<span class="sd">    array([[0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 1, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; ndimage.binary_propagation(b, mask=a).astype(int)</span>
<span class="sd">    array([[0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 1, 1, 1, 0],</span>
<span class="sd">           [0, 0, 1, 1, 1, 0],</span>
<span class="sd">           [0, 0, 1, 1, 1, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">binary_dilation</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span>
                           <span class="n">border_value</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">binary_fill_holes</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fill the holes in binary objects.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input : array_like</span>
<span class="sd">        N-D binary array with holes to be filled</span>
<span class="sd">    structure : array_like, optional</span>
<span class="sd">        Structuring element used in the computation; large-size elements</span>
<span class="sd">        make computations faster but may miss holes separated from the</span>
<span class="sd">        background by thin regions. The default element (with a square</span>
<span class="sd">        connectivity equal to one) yields the intuitive result where all</span>
<span class="sd">        holes in the input have been filled.</span>
<span class="sd">    output : ndarray, optional</span>
<span class="sd">        Array of the same shape as input, into which the output is placed.</span>
<span class="sd">        By default, a new array is created.</span>
<span class="sd">    origin : int, tuple of ints, optional</span>
<span class="sd">        Position of the structuring element.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        Transformation of the initial image `input` where holes have been</span>
<span class="sd">        filled.</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    binary_dilation, binary_propagation, label</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The algorithm used in this function consists in invading the complementary</span>
<span class="sd">    of the shapes in `input` from the outer boundary of the image,</span>
<span class="sd">    using binary dilations. Holes are not connected to the boundary and are</span>
<span class="sd">    therefore not invaded. The result is the complementary subset of the</span>
<span class="sd">    invaded region.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] https://en.wikipedia.org/wiki/Mathematical_morphology</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy import ndimage</span>
<span class="sd">    &gt;&gt;&gt; a = np.zeros((5, 5), dtype=int)</span>
<span class="sd">    &gt;&gt;&gt; a[1:4, 1:4] = 1</span>
<span class="sd">    &gt;&gt;&gt; a[2,2] = 0</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 1, 1, 1, 0],</span>
<span class="sd">           [0, 1, 0, 1, 0],</span>
<span class="sd">           [0, 1, 1, 1, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; ndimage.binary_fill_holes(a).astype(int)</span>
<span class="sd">    array([[0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 1, 1, 1, 0],</span>
<span class="sd">           [0, 1, 1, 1, 0],</span>
<span class="sd">           [0, 1, 1, 1, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; # Too big structuring element</span>
<span class="sd">    &gt;&gt;&gt; ndimage.binary_fill_holes(a, structure=np.ones((5,5))).astype(int)</span>
<span class="sd">    array([[0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 1, 1, 1, 0],</span>
<span class="sd">           [0, 1, 0, 1, 0],</span>
<span class="sd">           [0, 1, 1, 1, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
    <span class="n">inplace</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="n">binary_dilation</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">binary_dilation</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
                                 <span class="n">origin</span><span class="p">)</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span>


<span class="k">def</span> <span class="nf">grey_erosion</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">footprint</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">output</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;reflect&quot;</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate a greyscale erosion, using either a structuring element,</span>
<span class="sd">    or a footprint corresponding to a flat structuring element.</span>

<span class="sd">    Grayscale erosion is a mathematical morphology operation. For the</span>
<span class="sd">    simple case of a full and flat structuring element, it can be viewed</span>
<span class="sd">    as a minimum filter over a sliding window.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input : array_like</span>
<span class="sd">        Array over which the grayscale erosion is to be computed.</span>
<span class="sd">    size : tuple of ints</span>
<span class="sd">        Shape of a flat and full structuring element used for the grayscale</span>
<span class="sd">        erosion. Optional if `footprint` or `structure` is provided.</span>
<span class="sd">    footprint : array of ints, optional</span>
<span class="sd">        Positions of non-infinite elements of a flat structuring element</span>
<span class="sd">        used for the grayscale erosion. Non-zero values give the set of</span>
<span class="sd">        neighbors of the center over which the minimum is chosen.</span>
<span class="sd">    structure : array of ints, optional</span>
<span class="sd">        Structuring element used for the grayscale erosion. `structure`</span>
<span class="sd">        may be a non-flat structuring element.</span>
<span class="sd">    output : array, optional</span>
<span class="sd">        An array used for storing the output of the erosion may be provided.</span>
<span class="sd">    mode : {&#39;reflect&#39;,&#39;constant&#39;,&#39;nearest&#39;,&#39;mirror&#39;, &#39;wrap&#39;}, optional</span>
<span class="sd">        The `mode` parameter determines how the array borders are</span>
<span class="sd">        handled, where `cval` is the value when mode is equal to</span>
<span class="sd">        &#39;constant&#39;. Default is &#39;reflect&#39;</span>
<span class="sd">    cval : scalar, optional</span>
<span class="sd">        Value to fill past edges of input if `mode` is &#39;constant&#39;. Default</span>
<span class="sd">        is 0.0.</span>
<span class="sd">    origin : scalar, optional</span>
<span class="sd">        The `origin` parameter controls the placement of the filter.</span>
<span class="sd">        Default 0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    output : ndarray</span>
<span class="sd">        Grayscale erosion of `input`.</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    binary_erosion, grey_dilation, grey_opening, grey_closing</span>
<span class="sd">    generate_binary_structure, minimum_filter</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The grayscale erosion of an image input by a structuring element s defined</span>
<span class="sd">    over a domain E is given by:</span>

<span class="sd">    (input+s)(x) = min {input(y) - s(x-y), for y in E}</span>

<span class="sd">    In particular, for structuring elements defined as</span>
<span class="sd">    s(y) = 0 for y in E, the grayscale erosion computes the minimum of the</span>
<span class="sd">    input image inside a sliding window defined by E.</span>

<span class="sd">    Grayscale erosion [1]_ is a *mathematical morphology* operation [2]_.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] https://en.wikipedia.org/wiki/Erosion_%28morphology%29</span>
<span class="sd">    .. [2] https://en.wikipedia.org/wiki/Mathematical_morphology</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy import ndimage</span>
<span class="sd">    &gt;&gt;&gt; a = np.zeros((7,7), dtype=int)</span>
<span class="sd">    &gt;&gt;&gt; a[1:6, 1:6] = 3</span>
<span class="sd">    &gt;&gt;&gt; a[4,4] = 2; a[2,3] = 1</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 3, 3, 3, 3, 3, 0],</span>
<span class="sd">           [0, 3, 3, 1, 3, 3, 0],</span>
<span class="sd">           [0, 3, 3, 3, 3, 3, 0],</span>
<span class="sd">           [0, 3, 3, 3, 2, 3, 0],</span>
<span class="sd">           [0, 3, 3, 3, 3, 3, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; ndimage.grey_erosion(a, size=(3,3))</span>
<span class="sd">    array([[0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 1, 1, 1, 0, 0],</span>
<span class="sd">           [0, 0, 1, 1, 1, 0, 0],</span>
<span class="sd">           [0, 0, 3, 2, 2, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; footprint = ndimage.generate_binary_structure(2, 1)</span>
<span class="sd">    &gt;&gt;&gt; footprint</span>
<span class="sd">    array([[False,  True, False],</span>
<span class="sd">           [ True,  True,  True],</span>
<span class="sd">           [False,  True, False]], dtype=bool)</span>
<span class="sd">    &gt;&gt;&gt; # Diagonally-connected elements are not considered neighbors</span>
<span class="sd">    &gt;&gt;&gt; ndimage.grey_erosion(a, size=(3,3), footprint=footprint)</span>
<span class="sd">    array([[0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 1, 1, 1, 0, 0],</span>
<span class="sd">           [0, 0, 3, 1, 2, 0, 0],</span>
<span class="sd">           [0, 0, 3, 2, 2, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">footprint</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">structure</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;size, footprint, or structure must be specified&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">filters</span><span class="o">.</span><span class="n">_min_or_max_filter</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">footprint</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span>
                                      <span class="n">output</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">cval</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">grey_dilation</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">footprint</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">output</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;reflect&quot;</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate a greyscale dilation, using either a structuring element,</span>
<span class="sd">    or a footprint corresponding to a flat structuring element.</span>

<span class="sd">    Grayscale dilation is a mathematical morphology operation. For the</span>
<span class="sd">    simple case of a full and flat structuring element, it can be viewed</span>
<span class="sd">    as a maximum filter over a sliding window.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input : array_like</span>
<span class="sd">        Array over which the grayscale dilation is to be computed.</span>
<span class="sd">    size : tuple of ints</span>
<span class="sd">        Shape of a flat and full structuring element used for the grayscale</span>
<span class="sd">        dilation. Optional if `footprint` or `structure` is provided.</span>
<span class="sd">    footprint : array of ints, optional</span>
<span class="sd">        Positions of non-infinite elements of a flat structuring element</span>
<span class="sd">        used for the grayscale dilation. Non-zero values give the set of</span>
<span class="sd">        neighbors of the center over which the maximum is chosen.</span>
<span class="sd">    structure : array of ints, optional</span>
<span class="sd">        Structuring element used for the grayscale dilation. `structure`</span>
<span class="sd">        may be a non-flat structuring element.</span>
<span class="sd">    output : array, optional</span>
<span class="sd">        An array used for storing the output of the dilation may be provided.</span>
<span class="sd">    mode : {&#39;reflect&#39;,&#39;constant&#39;,&#39;nearest&#39;,&#39;mirror&#39;, &#39;wrap&#39;}, optional</span>
<span class="sd">        The `mode` parameter determines how the array borders are</span>
<span class="sd">        handled, where `cval` is the value when mode is equal to</span>
<span class="sd">        &#39;constant&#39;. Default is &#39;reflect&#39;</span>
<span class="sd">    cval : scalar, optional</span>
<span class="sd">        Value to fill past edges of input if `mode` is &#39;constant&#39;. Default</span>
<span class="sd">        is 0.0.</span>
<span class="sd">    origin : scalar, optional</span>
<span class="sd">        The `origin` parameter controls the placement of the filter.</span>
<span class="sd">        Default 0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    grey_dilation : ndarray</span>
<span class="sd">        Grayscale dilation of `input`.</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    binary_dilation, grey_erosion, grey_closing, grey_opening</span>
<span class="sd">    generate_binary_structure, maximum_filter</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The grayscale dilation of an image input by a structuring element s defined</span>
<span class="sd">    over a domain E is given by:</span>

<span class="sd">    (input+s)(x) = max {input(y) + s(x-y), for y in E}</span>

<span class="sd">    In particular, for structuring elements defined as</span>
<span class="sd">    s(y) = 0 for y in E, the grayscale dilation computes the maximum of the</span>
<span class="sd">    input image inside a sliding window defined by E.</span>

<span class="sd">    Grayscale dilation [1]_ is a *mathematical morphology* operation [2]_.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] https://en.wikipedia.org/wiki/Dilation_%28morphology%29</span>
<span class="sd">    .. [2] https://en.wikipedia.org/wiki/Mathematical_morphology</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy import ndimage</span>
<span class="sd">    &gt;&gt;&gt; a = np.zeros((7,7), dtype=int)</span>
<span class="sd">    &gt;&gt;&gt; a[2:5, 2:5] = 1</span>
<span class="sd">    &gt;&gt;&gt; a[4,4] = 2; a[2,3] = 3</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 1, 3, 1, 0, 0],</span>
<span class="sd">           [0, 0, 1, 1, 1, 0, 0],</span>
<span class="sd">           [0, 0, 1, 1, 2, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; ndimage.grey_dilation(a, size=(3,3))</span>
<span class="sd">    array([[0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 1, 3, 3, 3, 1, 0],</span>
<span class="sd">           [0, 1, 3, 3, 3, 1, 0],</span>
<span class="sd">           [0, 1, 3, 3, 3, 2, 0],</span>
<span class="sd">           [0, 1, 1, 2, 2, 2, 0],</span>
<span class="sd">           [0, 1, 1, 2, 2, 2, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; ndimage.grey_dilation(a, footprint=np.ones((3,3)))</span>
<span class="sd">    array([[0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 1, 3, 3, 3, 1, 0],</span>
<span class="sd">           [0, 1, 3, 3, 3, 1, 0],</span>
<span class="sd">           [0, 1, 3, 3, 3, 2, 0],</span>
<span class="sd">           [0, 1, 1, 2, 2, 2, 0],</span>
<span class="sd">           [0, 1, 1, 2, 2, 2, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; s = ndimage.generate_binary_structure(2,1)</span>
<span class="sd">    &gt;&gt;&gt; s</span>
<span class="sd">    array([[False,  True, False],</span>
<span class="sd">           [ True,  True,  True],</span>
<span class="sd">           [False,  True, False]], dtype=bool)</span>
<span class="sd">    &gt;&gt;&gt; ndimage.grey_dilation(a, footprint=s)</span>
<span class="sd">    array([[0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 1, 3, 1, 0, 0],</span>
<span class="sd">           [0, 1, 3, 3, 3, 1, 0],</span>
<span class="sd">           [0, 1, 1, 3, 2, 1, 0],</span>
<span class="sd">           [0, 1, 1, 2, 2, 2, 0],</span>
<span class="sd">           [0, 0, 1, 1, 2, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; ndimage.grey_dilation(a, size=(3,3), structure=np.ones((3,3)))</span>
<span class="sd">    array([[1, 1, 1, 1, 1, 1, 1],</span>
<span class="sd">           [1, 2, 4, 4, 4, 2, 1],</span>
<span class="sd">           [1, 2, 4, 4, 4, 2, 1],</span>
<span class="sd">           [1, 2, 4, 4, 4, 3, 1],</span>
<span class="sd">           [1, 2, 2, 3, 3, 3, 1],</span>
<span class="sd">           [1, 2, 2, 3, 3, 3, 1],</span>
<span class="sd">           [1, 1, 1, 1, 1, 1, 1]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">footprint</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">structure</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;size, footprint, or structure must be specified&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">structure</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">structure</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span>
        <span class="n">structure</span> <span class="o">=</span> <span class="n">structure</span><span class="p">[</span><span class="nb">tuple</span><span class="p">([</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="o">*</span>
                                    <span class="n">structure</span><span class="o">.</span><span class="n">ndim</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">footprint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">footprint</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">footprint</span><span class="p">)</span>
        <span class="n">footprint</span> <span class="o">=</span> <span class="n">footprint</span><span class="p">[</span><span class="nb">tuple</span><span class="p">([</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="o">*</span>
                                    <span class="n">footprint</span><span class="o">.</span><span class="n">ndim</span><span class="p">)]</span>

    <span class="nb">input</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
    <span class="n">origin</span> <span class="o">=</span> <span class="n">_ni_support</span><span class="o">.</span><span class="n">_normalize_sequence</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="nb">input</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">origin</span><span class="p">)):</span>
        <span class="n">origin</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">origin</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">footprint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sz</span> <span class="o">=</span> <span class="n">footprint</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">structure</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sz</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
            <span class="n">sz</span> <span class="o">=</span> <span class="n">size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sz</span> <span class="o">=</span> <span class="n">size</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">sz</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">origin</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">filters</span><span class="o">.</span><span class="n">_min_or_max_filter</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">footprint</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span>
                                      <span class="n">output</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">cval</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">grey_opening</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">footprint</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">output</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;reflect&quot;</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Multidimensional grayscale opening.</span>

<span class="sd">    A grayscale opening consists in the succession of a grayscale erosion,</span>
<span class="sd">    and a grayscale dilation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input : array_like</span>
<span class="sd">        Array over which the grayscale opening is to be computed.</span>
<span class="sd">    size : tuple of ints</span>
<span class="sd">        Shape of a flat and full structuring element used for the grayscale</span>
<span class="sd">        opening. Optional if `footprint` or `structure` is provided.</span>
<span class="sd">    footprint : array of ints, optional</span>
<span class="sd">        Positions of non-infinite elements of a flat structuring element</span>
<span class="sd">        used for the grayscale opening.</span>
<span class="sd">    structure : array of ints, optional</span>
<span class="sd">        Structuring element used for the grayscale opening. `structure`</span>
<span class="sd">        may be a non-flat structuring element.</span>
<span class="sd">    output : array, optional</span>
<span class="sd">        An array used for storing the output of the opening may be provided.</span>
<span class="sd">    mode : {&#39;reflect&#39;, &#39;constant&#39;, &#39;nearest&#39;, &#39;mirror&#39;, &#39;wrap&#39;}, optional</span>
<span class="sd">        The `mode` parameter determines how the array borders are</span>
<span class="sd">        handled, where `cval` is the value when mode is equal to</span>
<span class="sd">        &#39;constant&#39;. Default is &#39;reflect&#39;</span>
<span class="sd">    cval : scalar, optional</span>
<span class="sd">        Value to fill past edges of input if `mode` is &#39;constant&#39;. Default</span>
<span class="sd">        is 0.0.</span>
<span class="sd">    origin : scalar, optional</span>
<span class="sd">        The `origin` parameter controls the placement of the filter.</span>
<span class="sd">        Default 0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    grey_opening : ndarray</span>
<span class="sd">        Result of the grayscale opening of `input` with `structure`.</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    binary_opening, grey_dilation, grey_erosion, grey_closing</span>
<span class="sd">    generate_binary_structure</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The action of a grayscale opening with a flat structuring element amounts</span>
<span class="sd">    to smoothen high local maxima, whereas binary opening erases small objects.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] https://en.wikipedia.org/wiki/Mathematical_morphology</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy import ndimage</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(36).reshape((6,6))</span>
<span class="sd">    &gt;&gt;&gt; a[3, 3] = 50</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[ 0,  1,  2,  3,  4,  5],</span>
<span class="sd">           [ 6,  7,  8,  9, 10, 11],</span>
<span class="sd">           [12, 13, 14, 15, 16, 17],</span>
<span class="sd">           [18, 19, 20, 50, 22, 23],</span>
<span class="sd">           [24, 25, 26, 27, 28, 29],</span>
<span class="sd">           [30, 31, 32, 33, 34, 35]])</span>
<span class="sd">    &gt;&gt;&gt; ndimage.grey_opening(a, size=(3,3))</span>
<span class="sd">    array([[ 0,  1,  2,  3,  4,  4],</span>
<span class="sd">           [ 6,  7,  8,  9, 10, 10],</span>
<span class="sd">           [12, 13, 14, 15, 16, 16],</span>
<span class="sd">           [18, 19, 20, 22, 22, 22],</span>
<span class="sd">           [24, 25, 26, 27, 28, 28],</span>
<span class="sd">           [24, 25, 26, 27, 28, 28]])</span>
<span class="sd">    &gt;&gt;&gt; # Note that the local maximum a[3,3] has disappeared</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">footprint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;ignoring size because footprint is set&quot;</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">grey_erosion</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">footprint</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span>
                       <span class="n">cval</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">grey_dilation</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">footprint</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span>
                         <span class="n">cval</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">grey_closing</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">footprint</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">output</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;reflect&quot;</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Multidimensional grayscale closing.</span>

<span class="sd">    A grayscale closing consists in the succession of a grayscale dilation,</span>
<span class="sd">    and a grayscale erosion.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input : array_like</span>
<span class="sd">        Array over which the grayscale closing is to be computed.</span>
<span class="sd">    size : tuple of ints</span>
<span class="sd">        Shape of a flat and full structuring element used for the grayscale</span>
<span class="sd">        closing. Optional if `footprint` or `structure` is provided.</span>
<span class="sd">    footprint : array of ints, optional</span>
<span class="sd">        Positions of non-infinite elements of a flat structuring element</span>
<span class="sd">        used for the grayscale closing.</span>
<span class="sd">    structure : array of ints, optional</span>
<span class="sd">        Structuring element used for the grayscale closing. `structure`</span>
<span class="sd">        may be a non-flat structuring element.</span>
<span class="sd">    output : array, optional</span>
<span class="sd">        An array used for storing the output of the closing may be provided.</span>
<span class="sd">    mode : {&#39;reflect&#39;, &#39;constant&#39;, &#39;nearest&#39;, &#39;mirror&#39;, &#39;wrap&#39;}, optional</span>
<span class="sd">        The `mode` parameter determines how the array borders are</span>
<span class="sd">        handled, where `cval` is the value when mode is equal to</span>
<span class="sd">        &#39;constant&#39;. Default is &#39;reflect&#39;</span>
<span class="sd">    cval : scalar, optional</span>
<span class="sd">        Value to fill past edges of input if `mode` is &#39;constant&#39;. Default</span>
<span class="sd">        is 0.0.</span>
<span class="sd">    origin : scalar, optional</span>
<span class="sd">        The `origin` parameter controls the placement of the filter.</span>
<span class="sd">        Default 0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    grey_closing : ndarray</span>
<span class="sd">        Result of the grayscale closing of `input` with `structure`.</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    binary_closing, grey_dilation, grey_erosion, grey_opening,</span>
<span class="sd">    generate_binary_structure</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The action of a grayscale closing with a flat structuring element amounts</span>
<span class="sd">    to smoothen deep local minima, whereas binary closing fills small holes.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] https://en.wikipedia.org/wiki/Mathematical_morphology</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy import ndimage</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(36).reshape((6,6))</span>
<span class="sd">    &gt;&gt;&gt; a[3,3] = 0</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[ 0,  1,  2,  3,  4,  5],</span>
<span class="sd">           [ 6,  7,  8,  9, 10, 11],</span>
<span class="sd">           [12, 13, 14, 15, 16, 17],</span>
<span class="sd">           [18, 19, 20,  0, 22, 23],</span>
<span class="sd">           [24, 25, 26, 27, 28, 29],</span>
<span class="sd">           [30, 31, 32, 33, 34, 35]])</span>
<span class="sd">    &gt;&gt;&gt; ndimage.grey_closing(a, size=(3,3))</span>
<span class="sd">    array([[ 7,  7,  8,  9, 10, 11],</span>
<span class="sd">           [ 7,  7,  8,  9, 10, 11],</span>
<span class="sd">           [13, 13, 14, 15, 16, 17],</span>
<span class="sd">           [19, 19, 20, 20, 22, 23],</span>
<span class="sd">           [25, 25, 26, 27, 28, 29],</span>
<span class="sd">           [31, 31, 32, 33, 34, 35]])</span>
<span class="sd">    &gt;&gt;&gt; # Note that the local minimum a[3,3] has disappeared</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">footprint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;ignoring size because footprint is set&quot;</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">grey_dilation</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">footprint</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span>
                        <span class="n">cval</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">grey_erosion</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">footprint</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span>
                        <span class="n">cval</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">morphological_gradient</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">footprint</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">output</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;reflect&quot;</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Multidimensional morphological gradient.</span>

<span class="sd">    The morphological gradient is calculated as the difference between a</span>
<span class="sd">    dilation and an erosion of the input with a given structuring element.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input : array_like</span>
<span class="sd">        Array over which to compute the morphlogical gradient.</span>
<span class="sd">    size : tuple of ints</span>
<span class="sd">        Shape of a flat and full structuring element used for the mathematical</span>
<span class="sd">        morphology operations. Optional if `footprint` or `structure` is</span>
<span class="sd">        provided. A larger `size` yields a more blurred gradient.</span>
<span class="sd">    footprint : array of ints, optional</span>
<span class="sd">        Positions of non-infinite elements of a flat structuring element</span>
<span class="sd">        used for the morphology operations. Larger footprints</span>
<span class="sd">        give a more blurred morphological gradient.</span>
<span class="sd">    structure : array of ints, optional</span>
<span class="sd">        Structuring element used for the morphology operations.</span>
<span class="sd">        `structure` may be a non-flat structuring element.</span>
<span class="sd">    output : array, optional</span>
<span class="sd">        An array used for storing the output of the morphological gradient</span>
<span class="sd">        may be provided.</span>
<span class="sd">    mode : {&#39;reflect&#39;, &#39;constant&#39;, &#39;nearest&#39;, &#39;mirror&#39;, &#39;wrap&#39;}, optional</span>
<span class="sd">        The `mode` parameter determines how the array borders are</span>
<span class="sd">        handled, where `cval` is the value when mode is equal to</span>
<span class="sd">        &#39;constant&#39;. Default is &#39;reflect&#39;</span>
<span class="sd">    cval : scalar, optional</span>
<span class="sd">        Value to fill past edges of input if `mode` is &#39;constant&#39;. Default</span>
<span class="sd">        is 0.0.</span>
<span class="sd">    origin : scalar, optional</span>
<span class="sd">        The `origin` parameter controls the placement of the filter.</span>
<span class="sd">        Default 0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    morphological_gradient : ndarray</span>
<span class="sd">        Morphological gradient of `input`.</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    grey_dilation, grey_erosion, gaussian_gradient_magnitude</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For a flat structuring element, the morphological gradient</span>
<span class="sd">    computed at a given point corresponds to the maximal difference</span>
<span class="sd">    between elements of the input among the elements covered by the</span>
<span class="sd">    structuring element centered on the point.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] https://en.wikipedia.org/wiki/Mathematical_morphology</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy import ndimage</span>
<span class="sd">    &gt;&gt;&gt; a = np.zeros((7,7), dtype=int)</span>
<span class="sd">    &gt;&gt;&gt; a[2:5, 2:5] = 1</span>
<span class="sd">    &gt;&gt;&gt; ndimage.morphological_gradient(a, size=(3,3))</span>
<span class="sd">    array([[0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 1, 1, 1, 1, 1, 0],</span>
<span class="sd">           [0, 1, 1, 1, 1, 1, 0],</span>
<span class="sd">           [0, 1, 1, 0, 1, 1, 0],</span>
<span class="sd">           [0, 1, 1, 1, 1, 1, 0],</span>
<span class="sd">           [0, 1, 1, 1, 1, 1, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; # The morphological gradient is computed as the difference</span>
<span class="sd">    &gt;&gt;&gt; # between a dilation and an erosion</span>
<span class="sd">    &gt;&gt;&gt; ndimage.grey_dilation(a, size=(3,3)) -\\</span>
<span class="sd">    ...  ndimage.grey_erosion(a, size=(3,3))</span>
<span class="sd">    array([[0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 1, 1, 1, 1, 1, 0],</span>
<span class="sd">           [0, 1, 1, 1, 1, 1, 0],</span>
<span class="sd">           [0, 1, 1, 0, 1, 1, 0],</span>
<span class="sd">           [0, 1, 1, 1, 1, 1, 0],</span>
<span class="sd">           [0, 1, 1, 1, 1, 1, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; a = np.zeros((7,7), dtype=int)</span>
<span class="sd">    &gt;&gt;&gt; a[2:5, 2:5] = 1</span>
<span class="sd">    &gt;&gt;&gt; a[4,4] = 2; a[2,3] = 3</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 1, 3, 1, 0, 0],</span>
<span class="sd">           [0, 0, 1, 1, 1, 0, 0],</span>
<span class="sd">           [0, 0, 1, 1, 2, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; ndimage.morphological_gradient(a, size=(3,3))</span>
<span class="sd">    array([[0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 1, 3, 3, 3, 1, 0],</span>
<span class="sd">           [0, 1, 3, 3, 3, 1, 0],</span>
<span class="sd">           [0, 1, 3, 2, 3, 2, 0],</span>
<span class="sd">           [0, 1, 1, 2, 2, 2, 0],</span>
<span class="sd">           [0, 1, 1, 2, 2, 2, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">grey_dilation</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">footprint</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span>
                        <span class="n">cval</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">grey_erosion</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">footprint</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span>
                     <span class="n">cval</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">-</span> <span class="n">grey_erosion</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">footprint</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span>
                                   <span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">cval</span><span class="p">,</span> <span class="n">origin</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">morphological_laplace</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">footprint</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">structure</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;reflect&quot;</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Multidimensional morphological laplace.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input : array_like</span>
<span class="sd">        Input.</span>
<span class="sd">    size : int or sequence of ints, optional</span>
<span class="sd">        See `structure`.</span>
<span class="sd">    footprint : bool or ndarray, optional</span>
<span class="sd">        See `structure`.</span>
<span class="sd">    structure : structure, optional</span>
<span class="sd">        Either `size`, `footprint`, or the `structure` must be provided.</span>
<span class="sd">    output : ndarray, optional</span>
<span class="sd">        An output array can optionally be provided.</span>
<span class="sd">    mode : {&#39;reflect&#39;,&#39;constant&#39;,&#39;nearest&#39;,&#39;mirror&#39;, &#39;wrap&#39;}, optional</span>
<span class="sd">        The mode parameter determines how the array borders are handled.</span>
<span class="sd">        For &#39;constant&#39; mode, values beyond borders are set to be `cval`.</span>
<span class="sd">        Default is &#39;reflect&#39;.</span>
<span class="sd">    cval : scalar, optional</span>
<span class="sd">        Value to fill past edges of input if mode is &#39;constant&#39;.</span>
<span class="sd">        Default is 0.0</span>
<span class="sd">    origin : origin, optional</span>
<span class="sd">        The origin parameter controls the placement of the filter.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    morphological_laplace : ndarray</span>
<span class="sd">        Output</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tmp1</span> <span class="o">=</span> <span class="n">grey_dilation</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">footprint</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span>
                         <span class="n">cval</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">grey_erosion</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">footprint</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span>
                     <span class="n">cval</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">tmp1</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tmp2</span> <span class="o">=</span> <span class="n">grey_erosion</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">footprint</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span>
                            <span class="n">cval</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">tmp1</span><span class="p">,</span> <span class="n">tmp2</span><span class="p">,</span> <span class="n">tmp2</span><span class="p">)</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">tmp2</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">tmp2</span><span class="p">)</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">tmp2</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">tmp2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tmp2</span>


<span class="k">def</span> <span class="nf">white_tophat</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">footprint</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">output</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;reflect&quot;</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Multidimensional white tophat filter.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input : array_like</span>
<span class="sd">        Input.</span>
<span class="sd">    size : tuple of ints</span>
<span class="sd">        Shape of a flat and full structuring element used for the filter.</span>
<span class="sd">        Optional if `footprint` or `structure` is provided.</span>
<span class="sd">    footprint : array of ints, optional</span>
<span class="sd">        Positions of elements of a flat structuring element</span>
<span class="sd">        used for the white tophat filter.</span>
<span class="sd">    structure : array of ints, optional</span>
<span class="sd">        Structuring element used for the filter. `structure`</span>
<span class="sd">        may be a non-flat structuring element.</span>
<span class="sd">    output : array, optional</span>
<span class="sd">        An array used for storing the output of the filter may be provided.</span>
<span class="sd">    mode : {&#39;reflect&#39;, &#39;constant&#39;, &#39;nearest&#39;, &#39;mirror&#39;, &#39;wrap&#39;}, optional</span>
<span class="sd">        The `mode` parameter determines how the array borders are</span>
<span class="sd">        handled, where `cval` is the value when mode is equal to</span>
<span class="sd">        &#39;constant&#39;. Default is &#39;reflect&#39;</span>
<span class="sd">    cval : scalar, optional</span>
<span class="sd">        Value to fill past edges of input if `mode` is &#39;constant&#39;.</span>
<span class="sd">        Default is 0.0.</span>
<span class="sd">    origin : scalar, optional</span>
<span class="sd">        The `origin` parameter controls the placement of the filter.</span>
<span class="sd">        Default is 0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    output : ndarray</span>
<span class="sd">        Result of the filter of `input` with `structure`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Subtract gray background from a bright peak.</span>

<span class="sd">    &gt;&gt;&gt; from scipy.ndimage import generate_binary_structure, white_tophat</span>
<span class="sd">    &gt;&gt;&gt; square = generate_binary_structure(rank=2, connectivity=3)</span>
<span class="sd">    &gt;&gt;&gt; bright_on_gray = np.array([[2, 3, 3, 3, 2],</span>
<span class="sd">    ...                            [3, 4, 5, 4, 3],</span>
<span class="sd">    ...                            [3, 5, 9, 5, 3],</span>
<span class="sd">    ...                            [3, 4, 5, 4, 3],</span>
<span class="sd">    ...                            [2, 3, 3, 3, 2]])</span>
<span class="sd">    &gt;&gt;&gt; white_tophat(input=bright_on_gray, structure=square)</span>
<span class="sd">    array([[0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 1, 0, 0],</span>
<span class="sd">           [0, 1, 5, 1, 0],</span>
<span class="sd">           [0, 0, 1, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0]])</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    black_tophat</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">footprint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;ignoring size because footprint is set&quot;</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">grey_erosion</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">footprint</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span>
                       <span class="n">cval</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">grey_dilation</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">footprint</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span>
                        <span class="n">cval</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">tmp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">output</span>

    <span class="k">if</span> <span class="nb">input</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">numpy</span><span class="o">.</span><span class="n">bool_</span> <span class="ow">and</span> <span class="n">tmp</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">numpy</span><span class="o">.</span><span class="n">bool_</span><span class="p">:</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">bitwise_xor</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">tmp</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">tmp</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tmp</span>


<span class="k">def</span> <span class="nf">black_tophat</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">footprint</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">structure</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;reflect&quot;</span><span class="p">,</span>
                 <span class="n">cval</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Multidimensional black tophat filter.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input : array_like</span>
<span class="sd">        Input.</span>
<span class="sd">    size : tuple of ints, optional</span>
<span class="sd">        Shape of a flat and full structuring element used for the filter.</span>
<span class="sd">        Optional if `footprint` or `structure` is provided.</span>
<span class="sd">    footprint : array of ints, optional</span>
<span class="sd">        Positions of non-infinite elements of a flat structuring element</span>
<span class="sd">        used for the black tophat filter.</span>
<span class="sd">    structure : array of ints, optional</span>
<span class="sd">        Structuring element used for the filter. `structure`</span>
<span class="sd">        may be a non-flat structuring element.</span>
<span class="sd">    output : array, optional</span>
<span class="sd">        An array used for storing the output of the filter may be provided.</span>
<span class="sd">    mode : {&#39;reflect&#39;, &#39;constant&#39;, &#39;nearest&#39;, &#39;mirror&#39;, &#39;wrap&#39;}, optional</span>
<span class="sd">        The `mode` parameter determines how the array borders are</span>
<span class="sd">        handled, where `cval` is the value when mode is equal to</span>
<span class="sd">        &#39;constant&#39;. Default is &#39;reflect&#39;</span>
<span class="sd">    cval : scalar, optional</span>
<span class="sd">        Value to fill past edges of input if `mode` is &#39;constant&#39;. Default</span>
<span class="sd">        is 0.0.</span>
<span class="sd">    origin : scalar, optional</span>
<span class="sd">        The `origin` parameter controls the placement of the filter.</span>
<span class="sd">        Default 0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    black_tophat : ndarray</span>
<span class="sd">        Result of the filter of `input` with `structure`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Change dark peak to bright peak and subtract background.</span>

<span class="sd">    &gt;&gt;&gt; from scipy.ndimage import generate_binary_structure, black_tophat</span>
<span class="sd">    &gt;&gt;&gt; square = generate_binary_structure(rank=2, connectivity=3)</span>
<span class="sd">    &gt;&gt;&gt; dark_on_gray = np.array([[7, 6, 6, 6, 7],</span>
<span class="sd">    ...                          [6, 5, 4, 5, 6],</span>
<span class="sd">    ...                          [6, 4, 0, 4, 6],</span>
<span class="sd">    ...                          [6, 5, 4, 5, 6],</span>
<span class="sd">    ...                          [7, 6, 6, 6, 7]])</span>
<span class="sd">    &gt;&gt;&gt; black_tophat(input=dark_on_gray, structure=square)</span>
<span class="sd">    array([[0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 1, 0, 0],</span>
<span class="sd">           [0, 1, 5, 1, 0],</span>
<span class="sd">           [0, 0, 1, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0]])</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    white_tophat, grey_opening, grey_closing</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">footprint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;ignoring size because footprint is set&quot;</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">grey_dilation</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">footprint</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span>
                        <span class="n">cval</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">grey_erosion</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">footprint</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span>
                       <span class="n">cval</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">tmp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">output</span>

    <span class="k">if</span> <span class="nb">input</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">numpy</span><span class="o">.</span><span class="n">bool_</span> <span class="ow">and</span> <span class="n">tmp</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">numpy</span><span class="o">.</span><span class="n">bool_</span><span class="p">:</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">bitwise_xor</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">tmp</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">tmp</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tmp</span>


<span class="k">def</span> <span class="nf">distance_transform_bf</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span> <span class="n">sampling</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">return_distances</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                          <span class="n">distances</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Distance transform function by a brute force algorithm.</span>

<span class="sd">    This function calculates the distance transform of the `input`, by</span>
<span class="sd">    replacing each foreground (non-zero) element, with its</span>
<span class="sd">    shortest distance to the background (any zero-valued element).</span>

<span class="sd">    In addition to the distance transform, the feature transform can</span>
<span class="sd">    be calculated. In this case the index of the closest background</span>
<span class="sd">    element to each foreground element is returned in a separate array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input : array_like</span>
<span class="sd">        Input</span>
<span class="sd">    metric : {&#39;euclidean&#39;, &#39;taxicab&#39;, &#39;chessboard&#39;}, optional</span>
<span class="sd">        &#39;cityblock&#39; and &#39;manhattan&#39; are also valid, and map to &#39;taxicab&#39;.</span>
<span class="sd">        The default is &#39;euclidean&#39;.</span>
<span class="sd">    sampling : float, or sequence of float, optional</span>
<span class="sd">        This parameter is only used when `metric` is &#39;euclidean&#39;.</span>
<span class="sd">        Spacing of elements along each dimension. If a sequence, must be of</span>
<span class="sd">        length equal to the input rank; if a single number, this is used for</span>
<span class="sd">        all axes. If not specified, a grid spacing of unity is implied.</span>
<span class="sd">    return_distances : bool, optional</span>
<span class="sd">        Whether to calculate the distance transform.</span>
<span class="sd">        Default is True.</span>
<span class="sd">    return_indices : bool, optional</span>
<span class="sd">        Whether to calculate the feature transform.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    distances : ndarray, optional</span>
<span class="sd">        An output array to store the calculated distance transform, instead of</span>
<span class="sd">        returning it.</span>
<span class="sd">        `return_distances` must be True.</span>
<span class="sd">        It must be the same shape as `input`, and of type float64 if `metric`</span>
<span class="sd">        is &#39;euclidean&#39;, uint32 otherwise.</span>
<span class="sd">    indices : int32 ndarray, optional</span>
<span class="sd">        An output array to store the calculated feature transform, instead of</span>
<span class="sd">        returning it.</span>
<span class="sd">        `return_indicies` must be True.</span>
<span class="sd">        Its shape must be `(input.ndim,) + input.shape`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    distances : ndarray, optional</span>
<span class="sd">        The calculated distance transform. Returned only when</span>
<span class="sd">        `return_distances` is True and `distances` is not supplied.</span>
<span class="sd">        It will have the same shape as the input array.</span>
<span class="sd">    indices : int32 ndarray, optional</span>
<span class="sd">        The calculated feature transform. It has an input-shaped array for each</span>
<span class="sd">        dimension of the input. See distance_transform_edt documentation for an</span>
<span class="sd">        example.</span>
<span class="sd">        Returned only when `return_indices` is True and `indices` is not</span>
<span class="sd">        supplied.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function employs a slow brute force algorithm, see also the</span>
<span class="sd">    function distance_transform_cdt for more efficient taxicab and</span>
<span class="sd">    chessboard algorithms.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ft_inplace</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
    <span class="n">dt_inplace</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
    <span class="n">_distance_tranform_arg_check</span><span class="p">(</span>
        <span class="n">dt_inplace</span><span class="p">,</span> <span class="n">ft_inplace</span><span class="p">,</span> <span class="n">return_distances</span><span class="p">,</span> <span class="n">return_indices</span>
    <span class="p">)</span>

    <span class="n">tmp1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
    <span class="n">struct</span> <span class="o">=</span> <span class="n">generate_binary_structure</span><span class="p">(</span><span class="n">tmp1</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">tmp1</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
    <span class="n">tmp2</span> <span class="o">=</span> <span class="n">binary_dilation</span><span class="p">(</span><span class="n">tmp1</span><span class="p">,</span> <span class="n">struct</span><span class="p">)</span>
    <span class="n">tmp2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="n">tmp1</span><span class="p">,</span> <span class="n">tmp2</span><span class="p">)</span>
    <span class="n">tmp1</span> <span class="o">=</span> <span class="n">tmp1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span> <span class="o">-</span> <span class="n">tmp2</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
    <span class="n">metric</span> <span class="o">=</span> <span class="n">metric</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;euclidean&#39;</span><span class="p">:</span>
        <span class="n">metric</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">metric</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;taxicab&#39;</span><span class="p">,</span> <span class="s1">&#39;cityblock&#39;</span><span class="p">,</span> <span class="s1">&#39;manhattan&#39;</span><span class="p">]:</span>
        <span class="n">metric</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;chessboard&#39;</span><span class="p">:</span>
        <span class="n">metric</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;distance metric not supported&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sampling</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sampling</span> <span class="o">=</span> <span class="n">_ni_support</span><span class="o">.</span><span class="n">_normalize_sequence</span><span class="p">(</span><span class="n">sampling</span><span class="p">,</span> <span class="n">tmp1</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
        <span class="n">sampling</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">sampling</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">sampling</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">contiguous</span><span class="p">:</span>
            <span class="n">sampling</span> <span class="o">=</span> <span class="n">sampling</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">return_indices</span><span class="p">:</span>
        <span class="n">ft</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">tmp1</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ft</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">return_distances</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">distances</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">dt</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">tmp1</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dt</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">tmp1</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">distances</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">tmp1</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;distances array has wrong shape&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">distances</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;distances array must be float64&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">distances</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">uint32</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;distances array must be uint32&#39;</span><span class="p">)</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">distances</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">_nd_image</span><span class="o">.</span><span class="n">distance_transform_bf</span><span class="p">(</span><span class="n">tmp1</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">sampling</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">ft</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_indices</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">indices</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;indices array must be int32&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">indices</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">tmp1</span><span class="o">.</span><span class="n">ndim</span><span class="p">,)</span> <span class="o">+</span> <span class="n">tmp1</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;indices array has wrong shape&#39;</span><span class="p">)</span>
            <span class="n">tmp2</span> <span class="o">=</span> <span class="n">indices</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tmp2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">tmp1</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">ft</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">ft</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tmp2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">rtmp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">tmp2</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="o">...</span><span class="p">])[</span><span class="n">ft</span><span class="p">]</span>
            <span class="n">rtmp</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">tmp1</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">tmp2</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">rtmp</span>
        <span class="n">ft</span> <span class="o">=</span> <span class="n">tmp2</span>

    <span class="c1"># construct and return the result</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">return_distances</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">dt_inplace</span><span class="p">:</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_indices</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">ft_inplace</span><span class="p">:</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ft</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>


<span class="k">def</span> <span class="nf">distance_transform_cdt</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;chessboard&#39;</span><span class="p">,</span> <span class="n">return_distances</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">return_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">distances</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Distance transform for chamfer type of transforms.</span>

<span class="sd">    In addition to the distance transform, the feature transform can</span>
<span class="sd">    be calculated. In this case the index of the closest background</span>
<span class="sd">    element to each foreground element is returned in a separate array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input : array_like</span>
<span class="sd">        Input</span>
<span class="sd">    metric : {&#39;chessboard&#39;, &#39;taxicab&#39;} or array_like, optional</span>
<span class="sd">        The `metric` determines the type of chamfering that is done. If the</span>
<span class="sd">        `metric` is equal to &#39;taxicab&#39; a structure is generated using</span>
<span class="sd">        generate_binary_structure with a squared distance equal to 1. If</span>
<span class="sd">        the `metric` is equal to &#39;chessboard&#39;, a `metric` is generated</span>
<span class="sd">        using generate_binary_structure with a squared distance equal to</span>
<span class="sd">        the dimensionality of the array. These choices correspond to the</span>
<span class="sd">        common interpretations of the &#39;taxicab&#39; and the &#39;chessboard&#39;</span>
<span class="sd">        distance metrics in two dimensions.</span>
<span class="sd">        A custom metric may be provided, in the form of a matrix where</span>
<span class="sd">        each dimension has a length of three.</span>
<span class="sd">        &#39;cityblock&#39; and &#39;manhattan&#39; are also valid, and map to &#39;taxicab&#39;.</span>
<span class="sd">        The default is &#39;chessboard&#39;.</span>
<span class="sd">    return_distances : bool, optional</span>
<span class="sd">        Whether to calculate the distance transform.</span>
<span class="sd">        Default is True.</span>
<span class="sd">    return_indices : bool, optional</span>
<span class="sd">        Whether to calculate the feature transform.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    distances : int32 ndarray, optional</span>
<span class="sd">        An output array to store the calculated distance transform, instead of</span>
<span class="sd">        returning it.</span>
<span class="sd">        `return_distances` must be True.</span>
<span class="sd">        It must be the same shape as `input`.</span>
<span class="sd">    indices : int32 ndarray, optional</span>
<span class="sd">        An output array to store the calculated feature transform, instead of</span>
<span class="sd">        returning it.</span>
<span class="sd">        `return_indicies` must be True.</span>
<span class="sd">        Its shape must be `(input.ndim,) + input.shape`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    distances : int32 ndarray, optional</span>
<span class="sd">        The calculated distance transform. Returned only when</span>
<span class="sd">        `return_distances` is True, and `distances` is not supplied.</span>
<span class="sd">        It will have the same shape as the input array.</span>
<span class="sd">    indices : int32 ndarray, optional</span>
<span class="sd">        The calculated feature transform. It has an input-shaped array for each</span>
<span class="sd">        dimension of the input. See distance_transform_edt documentation for an</span>
<span class="sd">        example.</span>
<span class="sd">        Returned only when `return_indices` is True, and `indices` is not</span>
<span class="sd">        supplied.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ft_inplace</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
    <span class="n">dt_inplace</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
    <span class="n">_distance_tranform_arg_check</span><span class="p">(</span>
        <span class="n">dt_inplace</span><span class="p">,</span> <span class="n">ft_inplace</span><span class="p">,</span> <span class="n">return_distances</span><span class="p">,</span> <span class="n">return_indices</span>
    <span class="p">)</span>
    <span class="nb">input</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">metric</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;taxicab&#39;</span><span class="p">,</span> <span class="s1">&#39;cityblock&#39;</span><span class="p">,</span> <span class="s1">&#39;manhattan&#39;</span><span class="p">]:</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">metric</span> <span class="o">=</span> <span class="n">generate_binary_structure</span><span class="p">(</span><span class="n">rank</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;chessboard&#39;</span><span class="p">:</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">metric</span> <span class="o">=</span> <span class="n">generate_binary_structure</span><span class="p">(</span><span class="n">rank</span><span class="p">,</span> <span class="n">rank</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">metric</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">metric</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;invalid metric provided&#39;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">metric</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;metric sizes must be equal to 3&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">metric</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">contiguous</span><span class="p">:</span>
        <span class="n">metric</span> <span class="o">=</span> <span class="n">metric</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">dt_inplace</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">distances</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;distances must be of int32 type&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">distances</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="nb">input</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;distances has wrong shape&#39;</span><span class="p">)</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">distances</span>
        <span class="n">dt</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

    <span class="n">rank</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">ndim</span>
    <span class="k">if</span> <span class="n">return_indices</span><span class="p">:</span>
        <span class="n">sz</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">ft</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">sz</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">ft</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ft</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">_nd_image</span><span class="o">.</span><span class="n">distance_transform_op</span><span class="p">(</span><span class="n">metric</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">ft</span><span class="p">)</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span><span class="p">[</span><span class="nb">tuple</span><span class="p">([</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="o">*</span> <span class="n">rank</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">return_indices</span><span class="p">:</span>
        <span class="n">ft</span> <span class="o">=</span> <span class="n">ft</span><span class="p">[</span><span class="nb">tuple</span><span class="p">([</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="o">*</span> <span class="n">rank</span><span class="p">)]</span>
    <span class="n">_nd_image</span><span class="o">.</span><span class="n">distance_transform_op</span><span class="p">(</span><span class="n">metric</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">ft</span><span class="p">)</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span><span class="p">[</span><span class="nb">tuple</span><span class="p">([</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="o">*</span> <span class="n">rank</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">return_indices</span><span class="p">:</span>
        <span class="n">ft</span> <span class="o">=</span> <span class="n">ft</span><span class="p">[</span><span class="nb">tuple</span><span class="p">([</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="o">*</span> <span class="n">rank</span><span class="p">)]</span>
        <span class="n">ft</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">ft</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ft_inplace</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">indices</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;indices array must be int32&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">indices</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">ndim</span><span class="p">,)</span> <span class="o">+</span> <span class="n">dt</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;indices array has wrong shape&#39;</span><span class="p">)</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">indices</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">rtmp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="o">...</span><span class="p">])[</span><span class="n">ft</span><span class="p">]</span>
            <span class="n">rtmp</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">tmp</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">rtmp</span>
        <span class="n">ft</span> <span class="o">=</span> <span class="n">tmp</span>

    <span class="c1"># construct and return the result</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">return_distances</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">dt_inplace</span><span class="p">:</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_indices</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">ft_inplace</span><span class="p">:</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ft</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>


<div class="viewcode-block" id="distance_transform_edt"><a class="viewcode-back" href="../../../core.html#core.distance_transform_edt">[docs]</a><span class="k">def</span> <span class="nf">distance_transform_edt</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">sampling</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_distances</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">return_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">distances</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Exact Euclidean distance transform.</span>

<span class="sd">    In addition to the distance transform, the feature transform can</span>
<span class="sd">    be calculated. In this case the index of the closest background</span>
<span class="sd">    element to each foreground element is returned in a separate array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input : array_like</span>
<span class="sd">        Input data to transform. Can be any type but will be converted</span>
<span class="sd">        into binary: 1 wherever input equates to True, 0 elsewhere.</span>
<span class="sd">    sampling : float, or sequence of float, optional</span>
<span class="sd">        Spacing of elements along each dimension. If a sequence, must be of</span>
<span class="sd">        length equal to the input rank; if a single number, this is used for</span>
<span class="sd">        all axes. If not specified, a grid spacing of unity is implied.</span>
<span class="sd">    return_distances : bool, optional</span>
<span class="sd">        Whether to calculate the distance transform.</span>
<span class="sd">        Default is True.</span>
<span class="sd">    return_indices : bool, optional</span>
<span class="sd">        Whether to calculate the feature transform.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    distances : float64 ndarray, optional</span>
<span class="sd">        An output array to store the calculated distance transform, instead of</span>
<span class="sd">        returning it.</span>
<span class="sd">        `return_distances` must be True.</span>
<span class="sd">        It must be the same shape as `input`.</span>
<span class="sd">    indices : int32 ndarray, optional</span>
<span class="sd">        An output array to store the calculated feature transform, instead of</span>
<span class="sd">        returning it.</span>
<span class="sd">        `return_indicies` must be True.</span>
<span class="sd">        Its shape must be `(input.ndim,) + input.shape`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    distances : float64 ndarray, optional</span>
<span class="sd">        The calculated distance transform. Returned only when</span>
<span class="sd">        `return_distances` is True and `distances` is not supplied.</span>
<span class="sd">        It will have the same shape as the input array.</span>
<span class="sd">    indices : int32 ndarray, optional</span>
<span class="sd">        The calculated feature transform. It has an input-shaped array for each</span>
<span class="sd">        dimension of the input. See example below.</span>
<span class="sd">        Returned only when `return_indices` is True and `indices` is not</span>
<span class="sd">        supplied.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The Euclidean distance transform gives values of the Euclidean</span>
<span class="sd">    distance::</span>

<span class="sd">                    n</span>
<span class="sd">      y_i = sqrt(sum (x[i]-b[i])**2)</span>
<span class="sd">                    i</span>

<span class="sd">    where b[i] is the background point (value 0) with the smallest</span>
<span class="sd">    Euclidean distance to input points x[i], and n is the</span>
<span class="sd">    number of dimensions.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy import ndimage</span>
<span class="sd">    &gt;&gt;&gt; a = np.array(([0,1,1,1,1],</span>
<span class="sd">    ...               [0,0,1,1,1],</span>
<span class="sd">    ...               [0,1,1,1,1],</span>
<span class="sd">    ...               [0,1,1,1,0],</span>
<span class="sd">    ...               [0,1,1,0,0]))</span>
<span class="sd">    &gt;&gt;&gt; ndimage.distance_transform_edt(a)</span>
<span class="sd">    array([[ 0.    ,  1.    ,  1.4142,  2.2361,  3.    ],</span>
<span class="sd">           [ 0.    ,  0.    ,  1.    ,  2.    ,  2.    ],</span>
<span class="sd">           [ 0.    ,  1.    ,  1.4142,  1.4142,  1.    ],</span>
<span class="sd">           [ 0.    ,  1.    ,  1.4142,  1.    ,  0.    ],</span>
<span class="sd">           [ 0.    ,  1.    ,  1.    ,  0.    ,  0.    ]])</span>

<span class="sd">    With a sampling of 2 units along x, 1 along y:</span>

<span class="sd">    &gt;&gt;&gt; ndimage.distance_transform_edt(a, sampling=[2,1])</span>
<span class="sd">    array([[ 0.    ,  1.    ,  2.    ,  2.8284,  3.6056],</span>
<span class="sd">           [ 0.    ,  0.    ,  1.    ,  2.    ,  3.    ],</span>
<span class="sd">           [ 0.    ,  1.    ,  2.    ,  2.2361,  2.    ],</span>
<span class="sd">           [ 0.    ,  1.    ,  2.    ,  1.    ,  0.    ],</span>
<span class="sd">           [ 0.    ,  1.    ,  1.    ,  0.    ,  0.    ]])</span>

<span class="sd">    Asking for indices as well:</span>

<span class="sd">    &gt;&gt;&gt; edt, inds = ndimage.distance_transform_edt(a, return_indices=True)</span>
<span class="sd">    &gt;&gt;&gt; inds</span>
<span class="sd">    array([[[0, 0, 1, 1, 3],</span>
<span class="sd">            [1, 1, 1, 1, 3],</span>
<span class="sd">            [2, 2, 1, 3, 3],</span>
<span class="sd">            [3, 3, 4, 4, 3],</span>
<span class="sd">            [4, 4, 4, 4, 4]],</span>
<span class="sd">           [[0, 0, 1, 1, 4],</span>
<span class="sd">            [0, 1, 1, 1, 4],</span>
<span class="sd">            [0, 0, 1, 4, 4],</span>
<span class="sd">            [0, 0, 3, 3, 4],</span>
<span class="sd">            [0, 0, 3, 3, 4]]])</span>

<span class="sd">    With arrays provided for inplace outputs:</span>

<span class="sd">    &gt;&gt;&gt; indices = np.zeros(((np.ndim(a),) + a.shape), dtype=np.int32)</span>
<span class="sd">    &gt;&gt;&gt; ndimage.distance_transform_edt(a, return_indices=True, indices=indices)</span>
<span class="sd">    array([[ 0.    ,  1.    ,  1.4142,  2.2361,  3.    ],</span>
<span class="sd">           [ 0.    ,  0.    ,  1.    ,  2.    ,  2.    ],</span>
<span class="sd">           [ 0.    ,  1.    ,  1.4142,  1.4142,  1.    ],</span>
<span class="sd">           [ 0.    ,  1.    ,  1.4142,  1.    ,  0.    ],</span>
<span class="sd">           [ 0.    ,  1.    ,  1.    ,  0.    ,  0.    ]])</span>
<span class="sd">    &gt;&gt;&gt; indices</span>
<span class="sd">    array([[[0, 0, 1, 1, 3],</span>
<span class="sd">            [1, 1, 1, 1, 3],</span>
<span class="sd">            [2, 2, 1, 3, 3],</span>
<span class="sd">            [3, 3, 4, 4, 3],</span>
<span class="sd">            [4, 4, 4, 4, 4]],</span>
<span class="sd">           [[0, 0, 1, 1, 4],</span>
<span class="sd">            [0, 1, 1, 1, 4],</span>
<span class="sd">            [0, 0, 1, 4, 4],</span>
<span class="sd">            [0, 0, 3, 3, 4],</span>
<span class="sd">            [0, 0, 3, 3, 4]]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ft_inplace</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
    <span class="n">dt_inplace</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
    <span class="n">_distance_tranform_arg_check</span><span class="p">(</span>
        <span class="n">dt_inplace</span><span class="p">,</span> <span class="n">ft_inplace</span><span class="p">,</span> <span class="n">return_distances</span><span class="p">,</span> <span class="n">return_indices</span>
    <span class="p">)</span>

    <span class="c1"># calculate the feature transform</span>
    <span class="nb">input</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">int8</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">sampling</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sampling</span> <span class="o">=</span> <span class="n">_ni_support</span><span class="o">.</span><span class="n">_normalize_sequence</span><span class="p">(</span><span class="n">sampling</span><span class="p">,</span> <span class="nb">input</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
        <span class="n">sampling</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">sampling</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">sampling</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">contiguous</span><span class="p">:</span>
            <span class="n">sampling</span> <span class="o">=</span> <span class="n">sampling</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">ft_inplace</span><span class="p">:</span>
        <span class="n">ft</span> <span class="o">=</span> <span class="n">indices</span>
        <span class="k">if</span> <span class="n">ft</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">ndim</span><span class="p">,)</span> <span class="o">+</span> <span class="nb">input</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;indices array has wrong shape&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ft</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;indices array must be int32&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ft</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">input</span><span class="o">.</span><span class="n">ndim</span><span class="p">,)</span> <span class="o">+</span> <span class="nb">input</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

    <span class="n">_nd_image</span><span class="o">.</span><span class="n">euclidean_feature_transform</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">sampling</span><span class="p">,</span> <span class="n">ft</span><span class="p">)</span>
    <span class="c1"># if requested, calculate the distance transform</span>
    <span class="k">if</span> <span class="n">return_distances</span><span class="p">:</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">ft</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ft</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sampling</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sampling</span><span class="p">)):</span>
                <span class="n">dt</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">*=</span> <span class="n">sampling</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dt_inplace</span><span class="p">:</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">distances</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">dt</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;distances array has wrong shape&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">distances</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;distances array must be float64&#39;</span><span class="p">)</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">distances</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>

    <span class="c1"># construct and return the result</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">return_distances</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">dt_inplace</span><span class="p">:</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_indices</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">ft_inplace</span><span class="p">:</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ft</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<span class="k">def</span> <span class="nf">_distance_tranform_arg_check</span><span class="p">(</span><span class="n">distances_out</span><span class="p">,</span> <span class="n">indices_out</span><span class="p">,</span>
                                 <span class="n">return_distances</span><span class="p">,</span> <span class="n">return_indices</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Raise a RuntimeError if the arguments are invalid&quot;&quot;&quot;</span>
    <span class="n">error_msgs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">return_distances</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">return_indices</span><span class="p">):</span>
        <span class="n">error_msgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="s1">&#39;at least one of return_distances/return_indices must be True&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">distances_out</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">return_distances</span><span class="p">:</span>
        <span class="n">error_msgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="s1">&#39;return_distances must be True if distances is supplied&#39;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">indices_out</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">return_indices</span><span class="p">:</span>
        <span class="n">error_msgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;return_indices must be True if indices is supplied&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">error_msgs</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">error_msgs</span><span class="p">))</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">MLV_toolbox_python</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">MLV_toolbox_python</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, Dirk Bernhardt-Walther, Sadman Hossain.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.3.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
    </div>

    

    
  </body>
</html>